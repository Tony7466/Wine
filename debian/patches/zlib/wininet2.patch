description: revert upstream msvcrt commit 3c31cc5836026b45a40818ec874bbbcc4d6ad982

--- a/dlls/wininet/Makefile.in
+++ b/dlls/wininet/Makefile.in
@@ -4,8 +4,6 @@ IMPORTLIB = wininet
 IMPORTS   = mpr shlwapi shell32 user32 ws2_32 advapi32
 DELAYIMPORTS = secur32 crypt32 cryptui dhcpcsvc iphlpapi
 
-EXTRADLLFLAGS = -mno-cygwin
-
 C_SRCS = \
 	cookie.c \
 	dialogs.c \
--- a/dlls/wininet/cookie.c
+++ b/dlls/wininet/cookie.c
@@ -27,7 +27,6 @@
 #include <stdlib.h>
 #include <string.h>
 #include <assert.h>
-#include <wchar.h>
 
 #include "windef.h"
 #include "winbase.h"
@@ -174,7 +173,7 @@ static WCHAR *create_cookie_url(substr_t
     p += domain.len;
 
     for(i=0; i < path.len; i++)
-        p[i] = towlower(path.str[i]);
+        p[i] = tolowerW(path.str[i]);
     p[path.len] = 0;
 
     ret_path->str = p;
@@ -195,7 +194,7 @@ static cookie_container_t *get_cookie_co
         if(cookie_container->path.len < path.len)
             break;
 
-        if(path.len == cookie_container->path.len && !wcsnicmp(cookie_container->path.str, path.str, path.len))
+        if(path.len == cookie_container->path.len && !strncmpiW(cookie_container->path.str, path.str, path.len))
             return cookie_container;
     }
 
@@ -266,7 +265,7 @@ static cookie_t *find_cookie(cookie_cont
     cookie_t *iter;
 
     LIST_FOR_EACH_ENTRY(iter, &container->cookie_list, cookie_t, entry) {
-        if(lstrlenW(iter->name) == name.len && !wcsnicmp(iter->name, name.str, name.len))
+        if(strlenW(iter->name) == name.len && !strncmpiW(iter->name, name.str, name.len))
             return iter;
     }
 
@@ -295,7 +294,7 @@ static void replace_cookie(cookie_contai
 
 static BOOL cookie_match_path(cookie_container_t *container, substr_t path)
 {
-    return path.len >= container->path.len && !wcsnicmp(container->path.str, path.str, container->path.len);
+    return path.len >= container->path.len && !strncmpiW(container->path.str, path.str, container->path.len);
 }
 
 static BOOL load_persistent_cookie(substr_t domain, substr_t path)
@@ -604,9 +603,9 @@ static DWORD get_cookie(substr_t host, s
                     res->string_len += 2; /* '; ' */
                 res->cookies[res->cnt++] = cookie_iter;
 
-                res->string_len += lstrlenW(cookie_iter->name);
+                res->string_len += strlenW(cookie_iter->name);
                 if(*cookie_iter->data)
-                    res->string_len += 1 /* = */ + lstrlenW(cookie_iter->data);
+                    res->string_len += 1 /* = */ + strlenW(cookie_iter->data);
             }
         }
     }
@@ -625,13 +624,13 @@ static void cookie_set_to_string(const c
             *ptr++ = ' ';
         }
 
-        len = lstrlenW(cookie_set->cookies[i]->name);
+        len = strlenW(cookie_set->cookies[i]->name);
         memcpy(ptr, cookie_set->cookies[i]->name, len*sizeof(WCHAR));
         ptr += len;
 
         if(*cookie_set->cookies[i]->data) {
             *ptr++ = '=';
-            len = lstrlenW(cookie_set->cookies[i]->data);
+            len = strlenW(cookie_set->cookies[i]->data);
             memcpy(ptr, cookie_set->cookies[i]->data, len*sizeof(WCHAR));
             ptr += len;
         }
@@ -873,11 +872,11 @@ static BOOL is_domain_legal_for_cookie(s
         return FALSE;
     }
 
-    if(domain.len > full_domain.len || !wmemchr(domain.str, '.', domain.len) || !wmemchr(full_domain.str, '.', full_domain.len))
+    if(domain.len > full_domain.len || !memchrW(domain.str, '.', domain.len) || !memchrW(full_domain.str, '.', full_domain.len))
         return FALSE;
 
     ptr = full_domain.str + full_domain.len - domain.len;
-    if (wcsnicmp(domain.str, ptr, domain.len) || (full_domain.len > domain.len && ptr[-1] != '.')) {
+    if (strncmpiW(domain.str, ptr, domain.len) || (full_domain.len > domain.len && ptr[-1] != '.')) {
         SetLastError(ERROR_INVALID_PARAMETER);
         return FALSE;
     }
@@ -925,7 +924,7 @@ DWORD set_cookie(substr_t domain, substr
 
     /* lots of information can be parsed out of the cookie value */
 
-    if(!(end_ptr = wmemchr(data.str, ';', data.len)))
+    if(!(end_ptr = memchrW(data.str, ';', data.len)))
        end_ptr = data.str + data.len;
     value = substr(data.str, end_ptr-data.str);
     data.str += value.len;
@@ -950,10 +949,10 @@ DWORD set_cookie(substr_t domain, substr
         if(!data.len)
             break;
 
-        if(!(end_ptr = wmemchr(data.str, ';', data.len)))
+        if(!(end_ptr = memchrW(data.str, ';', data.len)))
             end_ptr = data.str + data.len;
 
-        if(data.len >= (len = ARRAY_SIZE(szDomain)) && !wcsnicmp(data.str, szDomain, len)) {
+        if(data.len >= (len = ARRAY_SIZE(szDomain)) && !strncmpiW(data.str, szDomain, len)) {
             substr_skip(&data, len);
 
             if(data.len && *data.str == '.')
@@ -964,11 +963,11 @@ DWORD set_cookie(substr_t domain, substr
 
             domain = substr(data.str, end_ptr-data.str);
             TRACE("Parsing new domain %s\n", debugstr_wn(domain.str, domain.len));
-        }else if(data.len >= (len = ARRAY_SIZE(szPath)) && !wcsnicmp(data.str, szPath, len)) {
+        }else if(data.len >= (len = ARRAY_SIZE(szPath)) && !strncmpiW(data.str, szPath, len)) {
             substr_skip(&data, len);
             path = substr(data.str, end_ptr - data.str);
             TRACE("Parsing new path %s\n", debugstr_wn(path.str, path.len));
-        }else if(data.len >= (len = ARRAY_SIZE(szExpires)) && !wcsnicmp(data.str, szExpires, len)) {
+        }else if(data.len >= (len = ARRAY_SIZE(szExpires)) && !strncmpiW(data.str, szExpires, len)) {
             SYSTEMTIME st;
             WCHAR buf[128];
 
@@ -987,10 +986,10 @@ DWORD set_cookie(substr_t domain, substr
                     }
                 }
             }
-        }else if(data.len >= (len = ARRAY_SIZE(szSecure)) && !wcsnicmp(data.str, szSecure, len)) {
+        }else if(data.len >= (len = ARRAY_SIZE(szSecure)) && !strncmpiW(data.str, szSecure, len)) {
             substr_skip(&data, len);
             FIXME("secure not handled\n");
-        }else if(data.len >= (len = ARRAY_SIZE(szHttpOnly)) && !wcsnicmp(data.str, szHttpOnly, len)) {
+        }else if(data.len >= (len = ARRAY_SIZE(szHttpOnly)) && !strncmpiW(data.str, szHttpOnly, len)) {
             substr_skip(&data, len);
 
             if(!(flags & INTERNET_COOKIE_HTTPONLY)) {
@@ -1000,11 +999,11 @@ DWORD set_cookie(substr_t domain, substr
             }
 
             cookie_flags |= INTERNET_COOKIE_HTTPONLY;
-        }else if(data.len >= (len = ARRAY_SIZE(szVersion)) && !wcsnicmp(data.str, szVersion, len)) {
+        }else if(data.len >= (len = ARRAY_SIZE(szVersion)) && !strncmpiW(data.str, szVersion, len)) {
             substr_skip(&data, len);
 
             FIXME("version not handled (%s)\n",debugstr_wn(data.str, data.len));
-        }else if(data.len >= (len = ARRAY_SIZE(max_ageW)) && !wcsnicmp(data.str, max_ageW, len)) {
+        }else if(data.len >= (len = ARRAY_SIZE(max_ageW)) && !strncmpiW(data.str, max_ageW, len)) {
             /* Native doesn't support Max-Age attribute. */
             WARN("Max-Age ignored\n");
         }else if(data.len) {
@@ -1099,8 +1098,8 @@ DWORD WINAPI InternetSetCookieExW(LPCWST
         /* some apps (or is it us??) try to add a cookie with no cookie name, but
          * the cookie data in the form of name[=data].
          */
-        if (!(ptr = wcschr(lpCookieData, '=')))
-            ptr = lpCookieData + lstrlenW(lpCookieData);
+        if (!(ptr = strchrW(lpCookieData, '=')))
+            ptr = lpCookieData + strlenW(lpCookieData);
 
         name = substr(lpCookieData, ptr - lpCookieData);
         data = substrz(*ptr == '=' ? ptr+1 : ptr);
--- a/dlls/wininet/dialogs.c
+++ b/dlls/wininet/dialogs.c
@@ -35,6 +35,9 @@
 #include "cryptuiapi.h"
 
 #include "internet.h"
+
+#include "wine/unicode.h"
+
 #include "resource.h"
 
 #define MAX_STRING_LEN 1024
@@ -75,8 +78,8 @@ static BOOL WININET_GetAuthRealm( HINTER
      * FIXME: maybe we should check that we're
      * dealing with 'Basic' Authentication
      */
-    p = wcschr( szBuf, ' ' );
-    if( !p || wcsncmp( p+1, szRealm, lstrlenW(szRealm) ) )
+    p = strchrW( szBuf, ' ' );
+    if( !p || strncmpW( p+1, szRealm, strlenW(szRealm) ) )
     {
         ERR("response wrong? (%s)\n", debugstr_w(szBuf));
         return FALSE;
@@ -87,11 +90,11 @@ static BOOL WININET_GetAuthRealm( HINTER
     if( *p == '"' )
     {
         p++;
-        q = wcsrchr( p, '"' );
+        q = strrchrW( p, '"' );
         if( q )
             *q = 0;
     }
-    lstrcpyW( szBuf, p );
+    strcpyW( szBuf, p );
 
     return TRUE;
 }
@@ -134,11 +137,11 @@ static BOOL WININET_GetSetPassword( HWND
         szUserPass[0] = 0;
         GetWindowTextW( hUserItem, szUserPass, ARRAY_SIZE( szUserPass ) - 1 );
         lstrcatW(szUserPass, szColon);
-        u_len = lstrlenW( szUserPass );
+        u_len = strlenW( szUserPass );
         GetWindowTextW( hPassItem, szUserPass+u_len, ARRAY_SIZE( szUserPass ) - u_len );
 
-        r_len = (lstrlenW( szResource ) + 1)*sizeof(WCHAR);
-        u_len = (lstrlenW( szUserPass ) + 1)*sizeof(WCHAR);
+        r_len = (strlenW( szResource ) + 1)*sizeof(WCHAR);
+        u_len = (strlenW( szUserPass ) + 1)*sizeof(WCHAR);
         r = WNetCachePassword( (CHAR*)szResource, r_len,
                                (CHAR*)szUserPass, u_len, dwMagic, 0 );
 
@@ -146,13 +149,13 @@ static BOOL WININET_GetSetPassword( HWND
     }
 
     sz = sizeof szUserPass;
-    r_len = (lstrlenW( szResource ) + 1)*sizeof(WCHAR);
+    r_len = (strlenW( szResource ) + 1)*sizeof(WCHAR);
     r = WNetGetCachedPassword( (CHAR*)szResource, r_len,
                                (CHAR*)szUserPass, &sz, dwMagic );
     if( r != WN_SUCCESS )
         return FALSE;
 
-    p = wcschr( szUserPass, ':' );
+    p = strchrW( szUserPass, ':' );
     if( p )
     {
         *p = 0;
--- a/dlls/wininet/ftp.c
+++ b/dlls/wininet/ftp.c
@@ -834,8 +834,8 @@ static HINTERNET FTP_FtpFindFirstFileW(f
     if (lpszSearchFile)
     {
         LPCWSTR name = lpszSearchFile, p;
-        if ((p = wcsrchr( name, '\\' ))) name = p + 1;
-        if ((p = wcsrchr( name, '/' ))) name = p + 1;
+        if ((p = strrchrW( name, '\\' ))) name = p + 1;
+        if ((p = strrchrW( name, '/' ))) name = p + 1;
         if (name != lpszSearchFile)
         {
             lpszSearchPath = heap_strndupW(lpszSearchFile, name - lpszSearchFile);
@@ -2480,7 +2480,7 @@ HINTERNET FTP_Connect(appinfo_t *hIC, LP
     list_add_head( &hIC->hdr.children, &lpwfs->hdr.entry );
 
     if(hIC->proxy && hIC->accessType == INTERNET_OPEN_TYPE_PROXY) {
-        if(wcschr(hIC->proxy, ' '))
+        if(strchrW(hIC->proxy, ' '))
             FIXME("Several proxies not implemented.\n");
         if(hIC->proxyBypass)
             FIXME("Proxy bypass is ignored.\n");
@@ -2497,7 +2497,7 @@ HINTERNET FTP_Connect(appinfo_t *hIC, LP
             /* Nothing in the registry, get the username and use that as the password */
             if (!GetUserNameW(szPassword, &len)) {
                 /* Should never get here, but use an empty password as failsafe */
-                lstrcpyW(szPassword, szEmpty);
+                strcpyW(szPassword, szEmpty);
             }
         }
         RegCloseKey(key);
@@ -2525,7 +2525,7 @@ HINTERNET FTP_Connect(appinfo_t *hIC, LP
     }
         
     INTERNET_SendCallback(&hIC->hdr, dwContext, INTERNET_STATUS_RESOLVING_NAME,
-        (LPWSTR) lpszServerName, (lstrlenW(lpszServerName)+1) * sizeof(WCHAR));
+        (LPWSTR) lpszServerName, (strlenW(lpszServerName)+1) * sizeof(WCHAR));
 
     sock_namelen = sizeof(socketAddr);
     if (!GetAddress(lpszServerName, lpwfs->serverport, (struct sockaddr *)&socketAddr, &sock_namelen, szaddr))
@@ -3098,7 +3098,7 @@ static BOOL FTP_SendPort(ftp_session_t *
     BOOL bSuccess = FALSE;
     TRACE("\n");
 
-    swprintf(szIPAddress, ARRAY_SIZE(szIPAddress), szIPFormat,
+    sprintfW(szIPAddress, szIPFormat,
 	 lpwfs->lstnSocketAddress.sin_addr.S_un.S_addr&0x000000FF,
         (lpwfs->lstnSocketAddress.sin_addr.S_un.S_addr&0x0000FF00)>>8,
         (lpwfs->lstnSocketAddress.sin_addr.S_un.S_addr&0x00FF0000)>>16,
--- a/dlls/wininet/gopher.c
+++ b/dlls/wininet/gopher.c
@@ -18,6 +18,8 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
+#include "config.h"
+
 #include <stdarg.h>
 
 #include "windef.h"
--- a/dlls/wininet/http.c
+++ b/dlls/wininet/http.c
@@ -27,6 +27,8 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
+#include "config.h"
+
 #include <stdlib.h>
 
 #include "winsock2.h"
@@ -56,6 +58,7 @@
 #include "zlib.h"
 #include "wine/debug.h"
 #include "wine/exception.h"
+#include "wine/unicode.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(wininet);
 
@@ -234,20 +237,19 @@ void server_release(server_t *server)
 static BOOL process_host_port(server_t *server)
 {
     BOOL default_port;
-    size_t name_len, len;
+    size_t name_len;
     WCHAR *buf;
 
     static const WCHAR httpW[] = {'h','t','t','p',0};
     static const WCHAR httpsW[] = {'h','t','t','p','s',0};
     static const WCHAR formatW[] = {'%','s',':','/','/','%','s',':','%','u',0};
 
-    name_len = lstrlenW(server->name);
-    len = name_len + 10 /* strlen("://:<port>") */ + ARRAY_SIZE(httpsW);
-    buf = heap_alloc( len * sizeof(WCHAR) );
+    name_len = strlenW(server->name);
+    buf = heap_alloc((name_len + 10 /* strlen("://:<port>") */)*sizeof(WCHAR) + sizeof(httpsW));
     if(!buf)
         return FALSE;
 
-    swprintf(buf, len, formatW, server->is_https ? httpsW : httpW, server->name, server->port);
+    sprintfW(buf, formatW, server->is_https ? httpsW : httpW, server->name, server->port);
     server->scheme_host_port = buf;
 
     server->host_port = server->scheme_host_port + 7 /* strlen("http://") */;
@@ -266,7 +268,7 @@ server_t *get_server(substr_t name, INTE
     EnterCriticalSection(&connection_pool_cs);
 
     LIST_FOR_EACH_ENTRY(iter, &connection_pool, server_t, entry) {
-        if(iter->port == port && name.len == lstrlenW(iter->name) && !wcsnicmp(iter->name, name.str, name.len)
+        if(iter->port == port && name.len == strlenW(iter->name) && !strncmpiW(iter->name, name.str, name.len)
                 && iter->is_https == is_https) {
             server = iter;
             server_addref(server);
@@ -591,7 +593,7 @@ static void HTTP_FixURL(http_request_t *
         request->path = heap_strdupW(szSlash);
     else /* remove \r and \n*/
     {
-        int nLen = lstrlenW(request->path);
+        int nLen = strlenW(request->path);
         while ((nLen >0 ) && ((request->path[nLen-1] == '\r')||(request->path[nLen-1] == '\n')))
         {
             nLen--;
@@ -605,12 +607,12 @@ static void HTTP_FixURL(http_request_t *
     }
 
     if(CSTR_EQUAL != CompareStringW( LOCALE_INVARIANT, NORM_IGNORECASE,
-                       request->path, lstrlenW(request->path), szHttp, lstrlenW(szHttp) )
+                       request->path, strlenW(request->path), szHttp, strlenW(szHttp) )
        && request->path[0] != '/') /* not an absolute path ?? --> fix it !! */
     {
-        WCHAR *fixurl = heap_alloc((lstrlenW(request->path) + 2)*sizeof(WCHAR));
+        WCHAR *fixurl = heap_alloc((strlenW(request->path) + 2)*sizeof(WCHAR));
         *fixurl = '/';
-        lstrcpyW(fixurl + 1, request->path);
+        strcpyW(fixurl + 1, request->path);
         heap_free( request->path );
         request->path = fixurl;
     }
@@ -698,7 +700,7 @@ static WCHAR* build_response_header(http
     if (request->status_code)
     {
         req[n++] = request->version;
-        swprintf(buf, ARRAY_SIZE(buf), status_fmt, request->status_code);
+        sprintfW(buf, status_fmt, request->status_code);
         req[n++] = buf;
         req[n++] = request->statusText;
         if (use_cr)
@@ -709,7 +711,7 @@ static WCHAR* build_response_header(http
     for(i = 0; i < request->nCustHeaders; i++)
     {
         if(!(request->custHeaders[i].wFlags & HDR_ISREQUEST)
-                && wcscmp(request->custHeaders[i].lpszField, szStatus))
+                && strcmpW(request->custHeaders[i].lpszField, szStatus))
         {
             req[n++] = request->custHeaders[i].lpszField;
             req[n++] = colonW;
@@ -755,7 +757,7 @@ static void HTTP_ProcessCookies( http_re
         if (!setCookieHeader->lpszValue)
             continue;
 
-        data = wcschr(setCookieHeader->lpszValue, '=');
+        data = strchrW(setCookieHeader->lpszValue, '=');
         if(!data)
             continue;
 
@@ -776,9 +778,9 @@ static void strip_spaces(LPWSTR start)
         str++;
 
     if (str != start)
-        memmove(start, str, sizeof(WCHAR) * (lstrlenW(str) + 1));
+        memmove(start, str, sizeof(WCHAR) * (strlenW(str) + 1));
 
-    end = start + lstrlenW(start) - 1;
+    end = start + strlenW(start) - 1;
     while (end >= start && *end == ' ')
     {
         *end = '\0';
@@ -791,7 +793,7 @@ static inline BOOL is_basic_auth_value(
     static const WCHAR szBasic[] = {'B','a','s','i','c'}; /* Note: not nul-terminated */
     static const WCHAR szRealm[] = {'r','e','a','l','m'}; /* Note: not nul-terminated */
     BOOL is_basic;
-    is_basic = !wcsnicmp(pszAuthValue, szBasic, ARRAY_SIZE(szBasic)) &&
+    is_basic = !strncmpiW(pszAuthValue, szBasic, ARRAY_SIZE(szBasic)) &&
         ((pszAuthValue[ARRAY_SIZE(szBasic)] == ' ') || !pszAuthValue[ARRAY_SIZE(szBasic)]);
     if (is_basic && pszRealm)
     {
@@ -800,13 +802,13 @@ static inline BOOL is_basic_auth_value(
         LPCWSTR realm;
         ptr++;
         *pszRealm=NULL;
-        token = wcschr(ptr,'=');
+        token = strchrW(ptr,'=');
         if (!token)
             return TRUE;
         realm = ptr;
         while (*realm == ' ')
             realm++;
-        if(!wcsnicmp(realm, szRealm, ARRAY_SIZE(szRealm)) &&
+        if(!strncmpiW(realm, szRealm, ARRAY_SIZE(szRealm)) &&
             (realm[ARRAY_SIZE(szRealm)] == ' ' || realm[ARRAY_SIZE(szRealm)] == '='))
         {
             token++;
@@ -846,7 +848,7 @@ static UINT retrieve_cached_basic_author
     EnterCriticalSection(&authcache_cs);
     LIST_FOR_EACH_ENTRY(ad, &basicAuthorizationCache, basicAuthorizationData, entry)
     {
-        if (!wcsicmp(host, ad->host) && (!realm || !wcscmp(realm, ad->realm)))
+        if (!strcmpiW(host, ad->host) && (!realm || !strcmpW(realm, ad->realm)))
         {
             char *colon;
             DWORD length;
@@ -884,7 +886,7 @@ static void cache_basic_authorization(LP
     LIST_FOR_EACH(cursor, &basicAuthorizationCache)
     {
         basicAuthorizationData *check = LIST_ENTRY(cursor,basicAuthorizationData,entry);
-        if (!wcsicmp(host,check->host) && !wcscmp(realm,check->realm))
+        if (!strcmpiW(host,check->host) && !strcmpW(realm,check->realm))
         {
             ad = check;
             break;
@@ -922,7 +924,7 @@ static BOOL retrieve_cached_authorizatio
 
     EnterCriticalSection(&authcache_cs);
     LIST_FOR_EACH_ENTRY(ad, &authorizationCache, authorizationData, entry) {
-        if(!wcsicmp(host, ad->host) && !wcsicmp(scheme, ad->scheme)) {
+        if(!strcmpiW(host, ad->host) && !strcmpiW(scheme, ad->scheme)) {
             TRACE("Authorization found in cache\n");
 
             nt_auth_identity->User = heap_strdupW(ad->user);
@@ -960,7 +962,7 @@ static void cache_authorization(LPWSTR h
 
     EnterCriticalSection(&authcache_cs);
     LIST_FOR_EACH_ENTRY(ad, &authorizationCache, authorizationData, entry)
-        if(!wcsicmp(host, ad->host) && !wcsicmp(scheme, ad->scheme)) {
+        if(!strcmpiW(host, ad->host) && !strcmpiW(scheme, ad->scheme)) {
             found = TRUE;
             break;
         }
@@ -1086,7 +1088,7 @@ static BOOL HTTP_DoAuthorization( http_r
 
             if (domain_and_username)
             {
-                WCHAR *user = wcschr(domain_and_username, '\\');
+                WCHAR *user = strchrW(domain_and_username, '\\');
                 WCHAR *domain = domain_and_username;
 
                 /* FIXME: make sure scheme accepts SEC_WINNT_AUTH_IDENTITY before calling AcquireCredentialsHandle */
@@ -1102,11 +1104,11 @@ static BOOL HTTP_DoAuthorization( http_r
 
                 nt_auth_identity.Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;
                 nt_auth_identity.User = user;
-                nt_auth_identity.UserLength = lstrlenW(nt_auth_identity.User);
+                nt_auth_identity.UserLength = strlenW(nt_auth_identity.User);
                 nt_auth_identity.Domain = domain;
                 nt_auth_identity.DomainLength = domain ? user - domain - 1 : 0;
                 nt_auth_identity.Password = password;
-                nt_auth_identity.PasswordLength = lstrlenW(nt_auth_identity.Password);
+                nt_auth_identity.PasswordLength = strlenW(nt_auth_identity.Password);
 
                 cache_authorization(host, pAuthInfo->scheme, &nt_auth_identity);
             }
@@ -1152,8 +1154,8 @@ static BOOL HTTP_DoAuthorization( http_r
     else if (pAuthInfo->finished)
         return FALSE;
 
-    if ((lstrlenW(pszAuthValue) < lstrlenW(pAuthInfo->scheme)) ||
-        wcsnicmp(pszAuthValue, pAuthInfo->scheme, lstrlenW(pAuthInfo->scheme)))
+    if ((strlenW(pszAuthValue) < strlenW(pAuthInfo->scheme)) ||
+        strncmpiW(pszAuthValue, pAuthInfo->scheme, strlenW(pAuthInfo->scheme)))
     {
         ERR("authentication scheme changed from %s to %s\n",
             debugstr_w(pAuthInfo->scheme), debugstr_w(pszAuthValue));
@@ -1223,7 +1225,7 @@ static BOOL HTTP_DoAuthorization( http_r
         in_desc.cBuffers = 1;
         in_desc.pBuffers = &in;
 
-        pszAuthData = pszAuthValue + lstrlenW(pAuthInfo->scheme);
+        pszAuthData = pszAuthValue + strlenW(pAuthInfo->scheme);
         if (*pszAuthData == ' ')
         {
             pszAuthData++;
@@ -1289,7 +1291,7 @@ static DWORD HTTP_HttpAddRequestHeadersW
     TRACE("copying header: %s\n", debugstr_wn(lpszHeader, dwHeaderLength));
 
     if( dwHeaderLength == ~0U )
-        len = lstrlenW(lpszHeader);
+        len = strlenW(lpszHeader);
     else
         len = dwHeaderLength;
     buffer = heap_alloc(sizeof(WCHAR)*(len+1));
@@ -1637,7 +1639,7 @@ static UINT HTTP_DecodeBase64( LPCWSTR b
 static WCHAR *encode_auth_data( const WCHAR *scheme, const char *data, UINT data_len )
 {
     WCHAR *ret;
-    UINT len, scheme_len = lstrlenW( scheme );
+    UINT len, scheme_len = strlenW( scheme );
 
     /* scheme + space + base64 encoded data (3/2/1 bytes data -> 4 bytes of characters) */
     len = scheme_len + 1 + ((data_len + 2) * 4) / 3;
@@ -1669,7 +1671,7 @@ static BOOL HTTP_InsertAuthorization( ht
             /* clear the data as it isn't valid now that it has been sent to the
              * server, unless it's Basic authentication which doesn't do
              * connection tracking */
-            if (wcsicmp(pAuthInfo->scheme, wszBasic))
+            if (strcmpiW(pAuthInfo->scheme, wszBasic))
             {
                 heap_free(pAuthInfo->auth_data);
                 pAuthInfo->auth_data = NULL;
@@ -1689,7 +1691,7 @@ static BOOL HTTP_InsertAuthorization( ht
         char *data;
 
         /* Don't use cached credentials when a username or Authorization was specified */
-        if ((request->session->userName && request->session->userName[0]) || wcscmp(header, szAuthorization))
+        if ((request->session->userName && request->session->userName[0]) || strcmpW(header, szAuthorization))
             return TRUE;
 
         if (!(host = get_host_header(request)))
@@ -1723,8 +1725,8 @@ static WCHAR *build_proxy_path_url(http_
     DWORD size, len;
     WCHAR *url;
 
-    len = lstrlenW(req->server->scheme_host_port);
-    size = len + lstrlenW(req->path) + 1;
+    len = strlenW(req->server->scheme_host_port);
+    size = len + strlenW(req->path) + 1;
     if(*req->path != '/')
         size++;
     url = heap_alloc(size * sizeof(WCHAR));
@@ -1735,7 +1737,7 @@ static WCHAR *build_proxy_path_url(http_
     if(*req->path != '/')
         url[len++] = '/';
 
-    lstrcpyW(url+len, req->path);
+    strcpyW(url+len, req->path);
 
     TRACE("url=%s\n", debugstr_w(url));
     return url;
@@ -1747,11 +1749,11 @@ static BOOL HTTP_DomainMatches(LPCWSTR s
     const WCHAR *dot, *ptr;
     int len;
 
-    if(domain.len == ARRAY_SIZE(localW)-1 && !wcsnicmp(domain.str, localW, domain.len) && !wcschr(server, '.' ))
+    if(domain.len == ARRAY_SIZE(localW)-1 && !strncmpiW(domain.str, localW, domain.len) && !strchrW(server, '.' ))
         return TRUE;
 
     if(domain.len && *domain.str != '*')
-        return domain.len == lstrlenW(server) && !wcsnicmp(server, domain.str, domain.len);
+        return domain.len == strlenW(server) && !strncmpiW(server, domain.str, domain.len);
 
     if(domain.len < 2 || domain.str[1] != '.')
         return FALSE;
@@ -1760,11 +1762,11 @@ static BOOL HTTP_DomainMatches(LPCWSTR s
      * the wildcard exactly.  E.g. if the wildcard is *.a.b, and the
      * hostname is www.foo.a.b, it matches, but a.b does not.
      */
-    dot = wcschr(server, '.');
+    dot = strchrW(server, '.');
     if(!dot)
         return FALSE;
 
-    len = lstrlenW(dot + 1);
+    len = strlenW(dot + 1);
     if(len < domain.len - 2)
         return FALSE;
 
@@ -1773,7 +1775,7 @@ static BOOL HTTP_DomainMatches(LPCWSTR s
      * server's domain.
      */
     ptr = dot + 1 + len - domain.len + 2;
-    if(!wcsnicmp(ptr, domain.str+2, domain.len-2))
+    if(!strncmpiW(ptr, domain.str+2, domain.len-2))
         /* This is only a match if the preceding character is
          * a '.', i.e. that it is a matching domain.  E.g.
          * if domain is '*.b.c' and server is 'www.ab.c' they
@@ -1781,7 +1783,7 @@ static BOOL HTTP_DomainMatches(LPCWSTR s
          */
         return *(ptr - 1) == '.';
 
-    return len == domain.len-2 && !wcsnicmp(dot + 1, domain.str + 2, len);
+    return len == domain.len-2 && !strncmpiW(dot + 1, domain.str + 2, len);
 }
 
 static BOOL HTTP_ShouldBypassProxy(appinfo_t *lpwai, LPCWSTR server)
@@ -1794,11 +1796,11 @@ static BOOL HTTP_ShouldBypassProxy(appin
     while(1) {
         LPCWSTR tmp = ptr;
 
-        ptr = wcschr( ptr, ';' );
+        ptr = strchrW( ptr, ';' );
         if (!ptr)
-            ptr = wcschr( tmp, ' ' );
+            ptr = strchrW( tmp, ' ' );
         if (!ptr)
-            ptr = tmp + lstrlenW(tmp);
+            ptr = tmp + strlenW(tmp);
         ret = HTTP_DomainMatches( server, substr(tmp, ptr-tmp) );
         if (ret || !*ptr)
             break;
@@ -1823,14 +1825,14 @@ static BOOL HTTP_DealWithProxy(appinfo_t
     if(!proxy)
         return FALSE;
     if(CSTR_EQUAL != CompareStringW(LOCALE_SYSTEM_DEFAULT, NORM_IGNORECASE,
-                                    proxy, lstrlenW(szHttp), szHttp, lstrlenW(szHttp))) {
-        WCHAR *proxy_url = heap_alloc(lstrlenW(proxy)*sizeof(WCHAR) + sizeof(szHttp));
+                                    proxy, strlenW(szHttp), szHttp, strlenW(szHttp))) {
+        WCHAR *proxy_url = heap_alloc(strlenW(proxy)*sizeof(WCHAR) + sizeof(szHttp));
         if(!proxy_url) {
             heap_free(proxy);
             return FALSE;
         }
-        lstrcpyW(proxy_url, szHttp);
-        lstrcatW(proxy_url, proxy);
+        strcpyW(proxy_url, szHttp);
+        strcatW(proxy_url, proxy);
         heap_free(proxy);
         proxy = proxy_url;
     }
@@ -1864,7 +1866,7 @@ static DWORD HTTP_ResolveName(http_reque
     INTERNET_SendCallback(&request->hdr, request->hdr.dwContext,
                           INTERNET_STATUS_RESOLVING_NAME,
                           server->name,
-                          (lstrlenW(server->name)+1) * sizeof(WCHAR));
+                          (strlenW(server->name)+1) * sizeof(WCHAR));
 
     addr_len = sizeof(server->addr);
     if (!GetAddress(server->name, server->port, (SOCKADDR*)&server->addr, &addr_len, server->addr_str))
@@ -1894,20 +1896,20 @@ static WCHAR *compose_request_url(http_r
     else
         scheme = http;
 
-    len = lstrlenW(scheme) + lstrlenW(host) + (req->path[0] != '/' ? 1 : 0) + lstrlenW(req->path);
+    len = strlenW(scheme) + strlenW(host) + (req->path[0] != '/' ? 1 : 0) + strlenW(req->path);
     ptr = buf = heap_alloc((len+1) * sizeof(WCHAR));
     if(buf) {
-        lstrcpyW(ptr, scheme);
-        ptr += lstrlenW(ptr);
+        strcpyW(ptr, scheme);
+        ptr += strlenW(ptr);
 
-        lstrcpyW(ptr, host);
-        ptr += lstrlenW(ptr);
+        strcpyW(ptr, host);
+        ptr += strlenW(ptr);
 
         if(req->path[0] != '/')
             *ptr++ = '/';
 
-        lstrcpyW(ptr, req->path);
-        ptr += lstrlenW(ptr);
+        strcpyW(ptr, req->path);
+        ptr += strlenW(ptr);
         *ptr = 0;
     }
 
@@ -2022,7 +2024,7 @@ static BOOL HTTP_KeepAlive(http_request_
     /* as per RFC 2068, S8.1.2.1, if the client is HTTP/1.1 then assume that
      * the connection is keep-alive by default */
     if (HTTP_HttpQueryInfoW(request, HTTP_QUERY_VERSION, szVersion, &dwBufferSize, NULL) == ERROR_SUCCESS
-        && !wcsicmp(szVersion, g_szHttp1_1))
+        && !strcmpiW(szVersion, g_szHttp1_1))
     {
         keepalive = TRUE;
     }
@@ -2031,7 +2033,7 @@ static BOOL HTTP_KeepAlive(http_request_
     if (HTTP_HttpQueryInfoW(request, HTTP_QUERY_PROXY_CONNECTION, szConnectionResponse, &dwBufferSize, NULL) == ERROR_SUCCESS
         || HTTP_HttpQueryInfoW(request, HTTP_QUERY_CONNECTION, szConnectionResponse, &dwBufferSize, NULL) == ERROR_SUCCESS)
     {
-        keepalive = !wcsicmp(szConnectionResponse, szKeepAlive);
+        keepalive = !strcmpiW(szConnectionResponse, szKeepAlive);
     }
 
     return keepalive;
@@ -2051,14 +2053,14 @@ static DWORD str_to_buffer(const WCHAR *
     {
         WCHAR *buf = buffer;
 
-        if (str) len = lstrlenW(str);
+        if (str) len = strlenW(str);
         else len = 0;
         if (*size < (len + 1) * sizeof(WCHAR))
         {
             *size = (len + 1) * sizeof(WCHAR);
             return ERROR_INSUFFICIENT_BUFFER;
         }
-        if (str) lstrcpyW(buf, str);
+        if (str) strcpyW(buf, str);
         else buf[0] = 0;
 
         *size = len;
@@ -2396,7 +2398,7 @@ static void commit_cache_entry(http_requ
     req->hCacheFile = NULL;
 
     header = build_response_header(req, TRUE);
-    header_len = (header ? lstrlenW(header) : 0);
+    header_len = (header ? strlenW(header) : 0);
     res = CommitUrlCacheEntryW(req->req_file->url, req->req_file->file_name, req->expires,
              req->last_modified, NORMAL_CACHE_ENTRY,
             header, header_len, NULL, 0);
@@ -2444,12 +2446,12 @@ static void create_cache_entry(http_requ
                 while(*ptr==' ' || *ptr=='\t')
                     ptr++;
 
-                end = wcschr(ptr, ',');
+                end = strchrW(ptr, ',');
                 if(!end)
-                    end = ptr + lstrlenW(ptr);
+                    end = ptr + strlenW(ptr);
 
-                if(!wcsnicmp(ptr, no_cacheW, ARRAY_SIZE(no_cacheW)-1)
-                        || !wcsnicmp(ptr, no_storeW, ARRAY_SIZE(no_storeW)-1)) {
+                if(!strncmpiW(ptr, no_cacheW, ARRAY_SIZE(no_cacheW)-1)
+                        || !strncmpiW(ptr, no_storeW, ARRAY_SIZE(no_storeW)-1)) {
                     b = FALSE;
                     break;
                 }
@@ -2912,7 +2914,7 @@ static DWORD set_content_length(http_req
     WCHAR encoding[20];
     DWORD size;
 
-    if(request->status_code == HTTP_STATUS_NO_CONTENT || !wcscmp(request->verb, headW)) {
+    if(request->status_code == HTTP_STATUS_NO_CONTENT || !strcmpW(request->verb, headW)) {
         request->contentLength = request->netconn_stream.content_length = 0;
         return ERROR_SUCCESS;
     }
@@ -2929,7 +2931,7 @@ static DWORD set_content_length(http_req
 
     size = sizeof(encoding);
     if (HTTP_HttpQueryInfoW(request, HTTP_QUERY_TRANSFER_ENCODING, encoding, &size, NULL) == ERROR_SUCCESS &&
-        !wcsicmp(encoding, szChunked))
+        !strcmpiW(encoding, szChunked))
     {
         chunked_stream_t *chunked_stream;
 
@@ -2962,12 +2964,12 @@ static DWORD set_content_length(http_req
 
         encoding_idx = HTTP_GetCustomHeaderIndex(request, szContent_Encoding, 0, FALSE);
         if(encoding_idx != -1) {
-            if(!wcsicmp(request->custHeaders[encoding_idx].lpszValue, gzipW)) {
+            if(!strcmpiW(request->custHeaders[encoding_idx].lpszValue, gzipW)) {
                 HTTP_DeleteCustomHeader(request, encoding_idx);
                 LeaveCriticalSection( &request->headers_section );
                 return init_gzip_stream(request, TRUE);
             }
-            if(!wcsicmp(request->custHeaders[encoding_idx].lpszValue, deflateW)) {
+            if(!strcmpiW(request->custHeaders[encoding_idx].lpszValue, deflateW)) {
                 HTTP_DeleteCustomHeader(request, encoding_idx);
                 LeaveCriticalSection( &request->headers_section );
                 return init_gzip_stream(request, FALSE);
@@ -3066,7 +3068,7 @@ static DWORD drain_content(http_request_
     if(!is_valid_netconn(req->netconn))
         return ERROR_NO_DATA;
 
-    if(!wcscmp(req->verb, szHEAD))
+    if(!strcmpW(req->verb, szHEAD))
         return ERROR_SUCCESS;
 
     EnterCriticalSection( &req->read_section );
@@ -3380,14 +3382,14 @@ static DWORD HTTP_HttpOpenRequestW(http_
         len = 1;
         rc = UrlCanonicalizeW(lpszObjectName, &dummy, &len, URL_ESCAPE_SPACES_ONLY);
         if (rc != E_POINTER)
-            len = lstrlenW(lpszObjectName)+1;
+            len = strlenW(lpszObjectName)+1;
         request->path = heap_alloc(len*sizeof(WCHAR));
         rc = UrlCanonicalizeW(lpszObjectName, request->path, &len,
                    URL_ESCAPE_SPACES_ONLY);
         if (rc != S_OK)
         {
             ERR("Unable to escape string!(%s) (%d)\n",debugstr_w(lpszObjectName),rc);
-            lstrcpyW(request->path,lpszObjectName);
+            strcpyW(request->path,lpszObjectName);
         }
     }else {
         static const WCHAR slashW[] = {'/',0};
@@ -3598,7 +3600,7 @@ static DWORD HTTP_HttpQueryInfoW(http_re
                 return ERROR_OUTOFMEMORY;
             }
 
-            len = lstrlenW(headers) * sizeof(WCHAR);
+            len = strlenW(headers) * sizeof(WCHAR);
             if (len + sizeof(WCHAR) > *lpdwBufferLength)
             {
                 len += sizeof(WCHAR);
@@ -3632,7 +3634,7 @@ static DWORD HTTP_HttpQueryInfoW(http_re
                 return ERROR_OUTOFMEMORY;
             }
 
-            len = lstrlenW(headers) * sizeof(WCHAR);
+            len = strlenW(headers) * sizeof(WCHAR);
             if (len > *lpdwBufferLength)
             {
                 *lpdwBufferLength = len;
@@ -3663,7 +3665,7 @@ static DWORD HTTP_HttpQueryInfoW(http_re
     case HTTP_QUERY_STATUS_TEXT:
         if (request->statusText)
         {
-            DWORD len = lstrlenW(request->statusText);
+            DWORD len = strlenW(request->statusText);
             if (len + 1 > *lpdwBufferLength/sizeof(WCHAR))
             {
                 *lpdwBufferLength = (len + 1) * sizeof(WCHAR);
@@ -3683,7 +3685,7 @@ static DWORD HTTP_HttpQueryInfoW(http_re
     case HTTP_QUERY_VERSION:
         if (request->version)
         {
-            DWORD len = lstrlenW(request->version);
+            DWORD len = strlenW(request->version);
             if (len + 1 > *lpdwBufferLength/sizeof(WCHAR))
             {
                 *lpdwBufferLength = (len + 1) * sizeof(WCHAR);
@@ -3727,7 +3729,7 @@ static DWORD HTTP_HttpQueryInfoW(http_re
             DWORD size;
             static const WCHAR formatW[] = {'%','u',0};
 
-            size = swprintf(buf, ARRAY_SIZE(buf), formatW, request->status_code) * sizeof(WCHAR);
+            size = sprintfW(buf, formatW, request->status_code) * sizeof(WCHAR);
 
             if(size <= *lpdwBufferLength) {
                 memcpy(lpBuffer, buf, size+sizeof(WCHAR));
@@ -3773,7 +3775,7 @@ static DWORD HTTP_HttpQueryInfoW(http_re
         }
 
         errno = 0;
-        value = wcstoul( lphttpHdr->lpszValue, NULL, 10 );
+        value = strtoulW( lphttpHdr->lpszValue, NULL, 10 );
         if (value > UINT_MAX || (value == ULONG_MAX && errno == ERANGE))
         {
             LeaveCriticalSection( &request->headers_section );
@@ -3808,7 +3810,7 @@ static DWORD HTTP_HttpQueryInfoW(http_re
     }
     else if (lphttpHdr->lpszValue)
     {
-        DWORD len = (lstrlenW(lphttpHdr->lpszValue) + 1) * sizeof(WCHAR);
+        DWORD len = (strlenW(lphttpHdr->lpszValue) + 1) * sizeof(WCHAR);
 
         if (len > *lpdwBufferLength)
         {
@@ -4116,7 +4118,7 @@ static DWORD HTTP_HandleRedirect(http_re
 {
     URL_COMPONENTSW urlComponents = { sizeof(urlComponents) };
     http_session_t *session = request->session;
-    size_t url_len = lstrlenW(url);
+    size_t url_len = strlenW(url);
 
     if(url[0] == '/')
     {
@@ -4175,7 +4177,7 @@ static DWORD HTTP_HandleRedirect(http_re
 
         host = substr(urlComponents.lpszHostName, urlComponents.dwHostNameLength);
 
-        if(host.len != lstrlenW(request->server->name) || wcsnicmp(request->server->name, host.str, host.len)
+        if(host.len != strlenW(request->server->name) || strncmpiW(request->server->name, host.str, host.len)
            || request->server->port != urlComponents.nPort) {
             server_t *new_server;
 
@@ -4209,7 +4211,7 @@ static DWORD HTTP_HandleRedirect(http_re
         if (rc != S_OK)
         {
             ERR("Unable to escape string!(%s) (%d)\n",debugstr_w(path),rc);
-            lstrcpyW(request->path, path);
+            strcpyW(request->path, path);
         }
         heap_free(path);
     }
@@ -4232,14 +4234,14 @@ static LPWSTR HTTP_build_req( LPCWSTR *l
     LPWSTR str;
 
     for( t = list; *t ; t++  )
-        len += lstrlenW( *t );
+        len += strlenW( *t );
     len++;
 
     str = heap_alloc(len*sizeof(WCHAR));
     *str = 0;
 
     for( t = list; *t ; t++ )
-        lstrcatW( str, *t );
+        strcatW( str, *t );
 
     return str;
 }
@@ -4253,7 +4255,7 @@ static void HTTP_InsertCookies(http_requ
     if(res != ERROR_SUCCESS || !cookies)
         return;
 
-    HTTP_HttpAddRequestHeadersW(request, cookies, lstrlenW(cookies),
+    HTTP_HttpAddRequestHeadersW(request, cookies, strlenW(cookies),
                                 HTTP_ADDREQ_FLAG_REPLACE | HTTP_ADDREQ_FLAG_ADD);
     heap_free(cookies);
 }
@@ -4269,7 +4271,7 @@ static WORD HTTP_ParseWkday(LPCWSTR day)
                                      { 's','a','t',0 }};
     unsigned int i;
     for (i = 0; i < ARRAY_SIZE(days); i++)
-        if (!wcsicmp(day, days[i]))
+        if (!strcmpiW(day, days[i]))
             return i;
 
     /* Invalid */
@@ -4291,18 +4293,18 @@ static WORD HTTP_ParseMonth(LPCWSTR mont
     static const WCHAR nov[] = { 'n','o','v',0 };
     static const WCHAR dec[] = { 'd','e','c',0 };
 
-    if (!wcsicmp(month, jan)) return 1;
-    if (!wcsicmp(month, feb)) return 2;
-    if (!wcsicmp(month, mar)) return 3;
-    if (!wcsicmp(month, apr)) return 4;
-    if (!wcsicmp(month, may)) return 5;
-    if (!wcsicmp(month, jun)) return 6;
-    if (!wcsicmp(month, jul)) return 7;
-    if (!wcsicmp(month, aug)) return 8;
-    if (!wcsicmp(month, sep)) return 9;
-    if (!wcsicmp(month, oct)) return 10;
-    if (!wcsicmp(month, nov)) return 11;
-    if (!wcsicmp(month, dec)) return 12;
+    if (!strcmpiW(month, jan)) return 1;
+    if (!strcmpiW(month, feb)) return 2;
+    if (!strcmpiW(month, mar)) return 3;
+    if (!strcmpiW(month, apr)) return 4;
+    if (!strcmpiW(month, may)) return 5;
+    if (!strcmpiW(month, jun)) return 6;
+    if (!strcmpiW(month, jul)) return 7;
+    if (!strcmpiW(month, aug)) return 8;
+    if (!strcmpiW(month, sep)) return 9;
+    if (!strcmpiW(month, oct)) return 10;
+    if (!strcmpiW(month, nov)) return 11;
+    if (!strcmpiW(month, dec)) return 12;
     /* Invalid */
     return 0;
 }
@@ -4318,10 +4320,10 @@ static BOOL HTTP_ParseTime(SYSTEMTIME *s
     WCHAR *nextPtr;
     unsigned long num;
 
-    while (iswspace(*ptr))
+    while (isspaceW(*ptr))
         ptr++;
 
-    num = wcstoul(ptr, &nextPtr, 10);
+    num = strtoulW(ptr, &nextPtr, 10);
     if (!nextPtr || nextPtr <= ptr || *nextPtr != ':')
     {
         ERR("unexpected time format %s\n", debugstr_w(ptr));
@@ -4334,7 +4336,7 @@ static BOOL HTTP_ParseTime(SYSTEMTIME *s
     }
     ptr = nextPtr + 1;
     st->wHour = (WORD)num;
-    num = wcstoul(ptr, &nextPtr, 10);
+    num = strtoulW(ptr, &nextPtr, 10);
     if (!nextPtr || nextPtr <= ptr || *nextPtr != ':')
     {
         ERR("unexpected time format %s\n", debugstr_w(ptr));
@@ -4347,7 +4349,7 @@ static BOOL HTTP_ParseTime(SYSTEMTIME *s
     }
     ptr = nextPtr + 1;
     st->wMinute = (WORD)num;
-    num = wcstoul(ptr, &nextPtr, 10);
+    num = strtoulW(ptr, &nextPtr, 10);
     if (!nextPtr || nextPtr <= ptr)
     {
         ERR("unexpected time format %s\n", debugstr_w(ptr));
@@ -4371,7 +4373,7 @@ static BOOL HTTP_ParseDateAsAsctime(LPCW
     SYSTEMTIME st = { 0 };
     unsigned long num;
 
-    for (ptr = value, dayPtr = day; *ptr && !iswspace(*ptr) &&
+    for (ptr = value, dayPtr = day; *ptr && !isspaceW(*ptr) &&
          dayPtr - day < ARRAY_SIZE(day) - 1; ptr++, dayPtr++)
         *dayPtr = *ptr;
     *dayPtr = 0;
@@ -4382,10 +4384,10 @@ static BOOL HTTP_ParseDateAsAsctime(LPCW
         return FALSE;
     }
 
-    while (iswspace(*ptr))
+    while (isspaceW(*ptr))
         ptr++;
 
-    for (monthPtr = month; !iswspace(*ptr) && monthPtr - month < ARRAY_SIZE(month) - 1;
+    for (monthPtr = month; !isspaceW(*ptr) && monthPtr - month < ARRAY_SIZE(month) - 1;
          monthPtr++, ptr++)
         *monthPtr = *ptr;
     *monthPtr = 0;
@@ -4396,10 +4398,10 @@ static BOOL HTTP_ParseDateAsAsctime(LPCW
         return FALSE;
     }
 
-    while (iswspace(*ptr))
+    while (isspaceW(*ptr))
         ptr++;
 
-    num = wcstoul(ptr, &nextPtr, 10);
+    num = strtoulW(ptr, &nextPtr, 10);
     if (!nextPtr || nextPtr <= ptr || !num || num > 31)
     {
         ERR("unexpected day %s\n", debugstr_w(ptr));
@@ -4408,16 +4410,16 @@ static BOOL HTTP_ParseDateAsAsctime(LPCW
     ptr = nextPtr;
     st.wDay = (WORD)num;
 
-    while (iswspace(*ptr))
+    while (isspaceW(*ptr))
         ptr++;
 
     if (!HTTP_ParseTime(&st, &ptr))
         return FALSE;
 
-    while (iswspace(*ptr))
+    while (isspaceW(*ptr))
         ptr++;
 
-    num = wcstoul(ptr, &nextPtr, 10);
+    num = strtoulW(ptr, &nextPtr, 10);
     if (!nextPtr || nextPtr <= ptr || num < 1601 || num > 30827)
     {
         ERR("unexpected year %s\n", debugstr_w(ptr));
@@ -4426,13 +4428,13 @@ static BOOL HTTP_ParseDateAsAsctime(LPCW
     ptr = nextPtr;
     st.wYear = (WORD)num;
 
-    while (iswspace(*ptr))
+    while (isspaceW(*ptr))
         ptr++;
 
     /* asctime() doesn't report a timezone, but some web servers do, so accept
      * with or without GMT.
      */
-    if (*ptr && wcscmp(ptr, gmt))
+    if (*ptr && strcmpW(ptr, gmt))
     {
         ERR("unexpected timezone %s\n", debugstr_w(ptr));
         return FALSE;
@@ -4448,7 +4450,7 @@ static BOOL HTTP_ParseRfc1123Date(LPCWST
     unsigned long num;
     SYSTEMTIME st = { 0 };
 
-    ptr = wcschr(value, ',');
+    ptr = strchrW(value, ',');
     if (!ptr)
         return FALSE;
     if (ptr - value != 3)
@@ -4466,10 +4468,10 @@ static BOOL HTTP_ParseRfc1123Date(LPCWST
     }
     ptr++;
 
-    while (iswspace(*ptr))
+    while (isspaceW(*ptr))
         ptr++;
 
-    num = wcstoul(ptr, &nextPtr, 10);
+    num = strtoulW(ptr, &nextPtr, 10);
     if (!nextPtr || nextPtr <= ptr || !num || num > 31)
     {
         WARN("unexpected day %s\n", debugstr_w(value));
@@ -4478,10 +4480,10 @@ static BOOL HTTP_ParseRfc1123Date(LPCWST
     ptr = nextPtr;
     st.wDay = (WORD)num;
 
-    while (iswspace(*ptr))
+    while (isspaceW(*ptr))
         ptr++;
 
-    for (monthPtr = month; !iswspace(*ptr) && monthPtr - month < ARRAY_SIZE(month) - 1;
+    for (monthPtr = month; !isspaceW(*ptr) && monthPtr - month < ARRAY_SIZE(month) - 1;
          monthPtr++, ptr++)
         *monthPtr = *ptr;
     *monthPtr = 0;
@@ -4492,10 +4494,10 @@ static BOOL HTTP_ParseRfc1123Date(LPCWST
         return FALSE;
     }
 
-    while (iswspace(*ptr))
+    while (isspaceW(*ptr))
         ptr++;
 
-    num = wcstoul(ptr, &nextPtr, 10);
+    num = strtoulW(ptr, &nextPtr, 10);
     if (!nextPtr || nextPtr <= ptr || num < 1601 || num > 30827)
     {
         ERR("unexpected year %s\n", debugstr_w(value));
@@ -4507,10 +4509,10 @@ static BOOL HTTP_ParseRfc1123Date(LPCWST
     if (!HTTP_ParseTime(&st, &ptr))
         return FALSE;
 
-    while (iswspace(*ptr))
+    while (isspaceW(*ptr))
         ptr++;
 
-    if (wcscmp(ptr, gmt))
+    if (strcmpW(ptr, gmt))
     {
         ERR("unexpected time zone %s\n", debugstr_w(ptr));
         return FALSE;
@@ -4529,7 +4531,7 @@ static WORD HTTP_ParseWeekday(LPCWSTR da
                                      { 's','a','t','u','r','d','a','y',0 }};
     unsigned int i;
     for (i = 0; i < ARRAY_SIZE(days); i++)
-        if (!wcsicmp(day, days[i]))
+        if (!strcmpiW(day, days[i]))
             return i;
 
     /* Invalid */
@@ -4544,7 +4546,7 @@ static BOOL HTTP_ParseRfc850Date(LPCWSTR
     unsigned long num;
     SYSTEMTIME st = { 0 };
 
-    ptr = wcschr(value, ',');
+    ptr = strchrW(value, ',');
     if (!ptr)
         return FALSE;
     if (ptr - value == 3)
@@ -4576,10 +4578,10 @@ static BOOL HTTP_ParseRfc850Date(LPCWSTR
     }
     ptr++;
 
-    while (iswspace(*ptr))
+    while (isspaceW(*ptr))
         ptr++;
 
-    num = wcstoul(ptr, &nextPtr, 10);
+    num = strtoulW(ptr, &nextPtr, 10);
     if (!nextPtr || nextPtr <= ptr || !num || num > 31)
     {
         ERR("unexpected day %s\n", debugstr_w(value));
@@ -4613,7 +4615,7 @@ static BOOL HTTP_ParseRfc850Date(LPCWSTR
     }
     ptr++;
 
-    num = wcstoul(ptr, &nextPtr, 10);
+    num = strtoulW(ptr, &nextPtr, 10);
     if (!nextPtr || nextPtr <= ptr || num < 1601 || num > 30827)
     {
         ERR("unexpected year %s\n", debugstr_w(value));
@@ -4625,10 +4627,10 @@ static BOOL HTTP_ParseRfc850Date(LPCWSTR
     if (!HTTP_ParseTime(&st, &ptr))
         return FALSE;
 
-    while (iswspace(*ptr))
+    while (isspaceW(*ptr))
         ptr++;
 
-    if (wcscmp(ptr, gmt))
+    if (strcmpW(ptr, gmt))
     {
         ERR("unexpected time zone %s\n", debugstr_w(ptr));
         return FALSE;
@@ -4641,12 +4643,12 @@ static BOOL HTTP_ParseDate(LPCWSTR value
     static const WCHAR zero[] = { '0',0 };
     BOOL ret;
 
-    if (!wcscmp(value, zero))
+    if (!strcmpW(value, zero))
     {
         ft->dwLowDateTime = ft->dwHighDateTime = 0;
         ret = TRUE;
     }
-    else if (wcschr(value, ','))
+    else if (strchrW(value, ','))
     {
         ret = HTTP_ParseRfc1123Date(value, ft);
         if (!ret)
@@ -4683,12 +4685,12 @@ static void HTTP_ProcessExpires(http_req
 
         for (ptr = ccHeader->lpszValue; ptr && *ptr; )
         {
-            LPWSTR comma = wcschr(ptr, ','), end, equal;
+            LPWSTR comma = strchrW(ptr, ','), end, equal;
 
             if (comma)
                 end = comma;
             else
-                end = ptr + lstrlenW(ptr);
+                end = ptr + strlenW(ptr);
             for (equal = end - 1; equal > ptr && *equal != '='; equal--)
                 ;
             if (*equal == '=')
@@ -4696,12 +4698,12 @@ static void HTTP_ProcessExpires(http_req
                 static const WCHAR max_age[] = {
                     'm','a','x','-','a','g','e',0 };
 
-                if (!wcsnicmp(ptr, max_age, equal - ptr - 1))
+                if (!strncmpiW(ptr, max_age, equal - ptr - 1))
                 {
                     LPWSTR nextPtr;
                     unsigned long age;
 
-                    age = wcstoul(equal + 1, &nextPtr, 10);
+                    age = strtoulW(equal + 1, &nextPtr, 10);
                     if (nextPtr > equal + 1)
                     {
                         LARGE_INTEGER ft;
@@ -4720,7 +4722,7 @@ static void HTTP_ProcessExpires(http_req
             if (comma)
             {
                 ptr = comma + 1;
-                while (iswspace(*ptr))
+                while (isspaceW(*ptr))
                     ptr++;
             }
             else
@@ -4782,11 +4784,11 @@ static void http_process_keep_alive(http
     EnterCriticalSection( &req->headers_section );
 
     if ((index = HTTP_GetCustomHeaderIndex(req, szConnection, 0, FALSE)) != -1)
-        req->netconn->keep_alive = !wcsicmp(req->custHeaders[index].lpszValue, szKeepAlive);
+        req->netconn->keep_alive = !strcmpiW(req->custHeaders[index].lpszValue, szKeepAlive);
     else if ((index = HTTP_GetCustomHeaderIndex(req, szProxy_Connection, 0, FALSE)) != -1)
-        req->netconn->keep_alive = !wcsicmp(req->custHeaders[index].lpszValue, szKeepAlive);
+        req->netconn->keep_alive = !strcmpiW(req->custHeaders[index].lpszValue, szKeepAlive);
     else
-        req->netconn->keep_alive = !wcsicmp(req->version, g_szHttp1_1);
+        req->netconn->keep_alive = !strcmpiW(req->version, g_szHttp1_1);
 
     LeaveCriticalSection( &req->headers_section );
 }
@@ -4885,7 +4887,7 @@ static void set_content_length_header( h
         {'C','o','n','t','e','n','t','-','L','e','n','g','t','h',':',' ','%','u','\r','\n',0};
     WCHAR buf[ARRAY_SIZE(fmtW) + 10];
 
-    swprintf( buf, ARRAY_SIZE(buf), fmtW, len );
+    sprintfW( buf, fmtW, len );
     HTTP_HttpAddRequestHeadersW( request, buf, ~0u, flags );
 }
 
@@ -4919,7 +4921,7 @@ static DWORD HTTP_HttpSendRequestW(http_
     HTTP_ProcessHeader(request, hostW, request->server->canon_host_port,
                        HTTP_ADDREQ_FLAG_ADD_IF_NEW | HTTP_ADDHDR_FLAG_REQ);
 
-    if (dwContentLength || wcscmp(request->verb, szGET))
+    if (dwContentLength || strcmpW(request->verb, szGET))
     {
         set_content_length_header(request, dwContentLength, HTTP_ADDREQ_FLAG_ADD_IF_NEW);
         request->bytesToWrite = dwContentLength;
@@ -4930,23 +4932,23 @@ static DWORD HTTP_HttpSendRequestW(http_
         static const WCHAR user_agent[] = {'U','s','e','r','-','A','g','e','n','t',':',' ','%','s','\r','\n',0};
         int len;
 
-        len = lstrlenW(request->session->appInfo->agent) + lstrlenW(user_agent);
+        len = strlenW(request->session->appInfo->agent) + strlenW(user_agent);
         agent_header = heap_alloc(len * sizeof(WCHAR));
-        swprintf(agent_header, len, user_agent, request->session->appInfo->agent);
+        sprintfW(agent_header, user_agent, request->session->appInfo->agent);
 
-        HTTP_HttpAddRequestHeadersW(request, agent_header, lstrlenW(agent_header), HTTP_ADDREQ_FLAG_ADD_IF_NEW);
+        HTTP_HttpAddRequestHeadersW(request, agent_header, strlenW(agent_header), HTTP_ADDREQ_FLAG_ADD_IF_NEW);
         heap_free(agent_header);
     }
     if (request->hdr.dwFlags & INTERNET_FLAG_PRAGMA_NOCACHE)
     {
         static const WCHAR pragma_nocache[] = {'P','r','a','g','m','a',':',' ','n','o','-','c','a','c','h','e','\r','\n',0};
-        HTTP_HttpAddRequestHeadersW(request, pragma_nocache, lstrlenW(pragma_nocache), HTTP_ADDREQ_FLAG_ADD_IF_NEW);
+        HTTP_HttpAddRequestHeadersW(request, pragma_nocache, strlenW(pragma_nocache), HTTP_ADDREQ_FLAG_ADD_IF_NEW);
     }
-    if ((request->hdr.dwFlags & INTERNET_FLAG_NO_CACHE_WRITE) && wcscmp(request->verb, szGET))
+    if ((request->hdr.dwFlags & INTERNET_FLAG_NO_CACHE_WRITE) && strcmpW(request->verb, szGET))
     {
         static const WCHAR cache_control[] = {'C','a','c','h','e','-','C','o','n','t','r','o','l',':',
                                               ' ','n','o','-','c','a','c','h','e','\r','\n',0};
-        HTTP_HttpAddRequestHeadersW(request, cache_control, lstrlenW(cache_control), HTTP_ADDREQ_FLAG_ADD_IF_NEW);
+        HTTP_HttpAddRequestHeadersW(request, cache_control, strlenW(cache_control), HTTP_ADDREQ_FLAG_ADD_IF_NEW);
     }
 
     /* add the headers the caller supplied */
@@ -5111,7 +5113,7 @@ static DWORD HTTP_HttpSendRequestW(http_
                     if(!new_url)
                         break;
 
-                    if (wcscmp(request->verb, szGET) && wcscmp(request->verb, szHEAD) &&
+                    if (strcmpW(request->verb, szGET) && strcmpW(request->verb, szHEAD) &&
                         request->status_code != HTTP_STATUS_REDIRECT_KEEP_VERB)
                     {
                         heap_free(request->verb);
@@ -5305,7 +5307,7 @@ static DWORD HTTP_HttpEndRequestW(http_r
             if(!new_url)
                 break;
 
-            if (wcscmp(request->verb, szGET) && wcscmp(request->verb, szHEAD) &&
+            if (strcmpW(request->verb, szGET) && strcmpW(request->verb, szHEAD) &&
                 request->status_code != HTTP_STATUS_REDIRECT_KEEP_VERB)
             {
                 heap_free(request->verb);
@@ -5530,7 +5532,7 @@ BOOL WINAPI HttpSendRequestExW(HINTERNET
             if (lpBuffersIn->lpcszHeader)
             {
                 if (lpBuffersIn->dwHeadersLength == ~0u)
-                    size = (lstrlenW( lpBuffersIn->lpcszHeader ) + 1) * sizeof(WCHAR);
+                    size = (strlenW( lpBuffersIn->lpcszHeader ) + 1) * sizeof(WCHAR);
                 else
                     size = lpBuffersIn->dwHeadersLength * sizeof(WCHAR);
 
@@ -5628,7 +5630,7 @@ BOOL WINAPI HttpSendRequestW(HINTERNET h
         {
             DWORD size;
 
-            if (dwHeaderLength == ~0u) size = (lstrlenW(lpszHeaders) + 1) * sizeof(WCHAR);
+            if (dwHeaderLength == ~0u) size = (strlenW(lpszHeaders) + 1) * sizeof(WCHAR);
             else size = dwHeaderLength * sizeof(WCHAR);
 
             task->headers = heap_alloc(size);
@@ -5957,20 +5959,20 @@ static DWORD HTTP_GetResponseHeaders(htt
         rc += buflen;
         MultiByteToWideChar( CP_ACP, 0, bufferA, buflen, buffer, MAX_REPLY_LEN );
         /* check is this a status code line? */
-        if (!wcsncmp(buffer, g_szHttp1_0, 4))
+        if (!strncmpW(buffer, g_szHttp1_0, 4))
         {
             /* split the version from the status code */
-            status_code = wcschr( buffer, ' ' );
+            status_code = strchrW( buffer, ' ' );
             if( !status_code )
                 goto lend;
             *status_code++=0;
 
             /* split the status code from the status text */
-            status_text = wcschr( status_code, ' ' );
+            status_text = strchrW( status_code, ' ' );
             if( status_text )
                 *status_text++=0;
 
-            request->status_code = wcstol(status_code, NULL, 10);
+            request->status_code = atoiW(status_code);
 
             TRACE("version [%s] status code [%s] status text [%s]\n",
                debugstr_w(buffer), debugstr_w(status_code), debugstr_w(status_text) );
@@ -6063,7 +6065,7 @@ static LPWSTR * HTTP_InterpretHttpHeader
 
     pTokenPair = heap_alloc_zero(sizeof(*pTokenPair)*3);
 
-    pszColon = wcschr(buffer, ':');
+    pszColon = strchrW(buffer, ':');
     /* must have two tokens */
     if (!pszColon)
     {
@@ -6084,7 +6086,7 @@ static LPWSTR * HTTP_InterpretHttpHeader
 
     /* skip colon */
     pszColon++;
-    len = lstrlenW(pszColon);
+    len = strlenW(pszColon);
     pTokenPair[1] = heap_alloc((len + 1) * sizeof(WCHAR));
     if (!pTokenPair[1])
     {
@@ -6193,8 +6195,8 @@ static DWORD HTTP_ProcessHeader(http_req
         LPWSTR lpsztmp;
         WCHAR ch = 0;
         INT len = 0;
-        INT origlen = lstrlenW(lphttpHdr->lpszValue);
-        INT valuelen = lstrlenW(value);
+        INT origlen = strlenW(lphttpHdr->lpszValue);
+        INT valuelen = strlenW(value);
 
         if (dwModifier & HTTP_ADDHDR_FLAG_COALESCE_WITH_COMMA)
         {
@@ -6252,7 +6254,7 @@ static INT HTTP_GetCustomHeaderIndex(htt
 
     for (index = 0; index < request->nCustHeaders; index++)
     {
-        if (wcsicmp(request->custHeaders[index].lpszField, lpszField))
+        if (strcmpiW(request->custHeaders[index].lpszField, lpszField))
             continue;
 
         if (request_only && !(request->custHeaders[index].wFlags & HDR_ISREQUEST))
--- a/dlls/wininet/internet.c
+++ b/dlls/wininet/internet.c
@@ -26,6 +26,8 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
+#include "config.h"
+
 #include "winsock2.h"
 #include "ws2ipdef.h"
 
@@ -35,7 +37,6 @@
 #include <stdlib.h>
 #include <ctype.h>
 #include <assert.h>
-#include <wchar.h>
 
 #include "windef.h"
 #include "winbase.h"
@@ -57,6 +58,8 @@
 #include "internet.h"
 #include "resource.h"
 
+#include "wine/unicode.h"
+
 WINE_DEFAULT_DEBUG_CHANNEL(wininet);
 
 typedef struct
@@ -394,11 +397,11 @@ WCHAR *INTERNET_FindProxyForProtocol(LPC
     {
         LPCWSTR end, equal;
 
-        if (!(end = wcschr(ptr, ' ')))
-            end = ptr + lstrlenW(ptr);
-        if ((equal = wcschr(ptr, '=')) && equal < end &&
-             equal - ptr == lstrlenW(proto) &&
-             !wcsnicmp(proto, ptr, lstrlenW(proto)))
+        if (!(end = strchrW(ptr, ' ')))
+            end = ptr + strlenW(ptr);
+        if ((equal = strchrW(ptr, '=')) && equal < end &&
+             equal - ptr == strlenW(proto) &&
+             !strncmpiW(proto, ptr, strlenW(proto)))
         {
             ret = heap_strndupW(equal + 1, end - equal - 1);
             TRACE("found proxy for %s: %s\n", debugstr_w(proto), debugstr_w(ret));
@@ -415,9 +418,9 @@ WCHAR *INTERNET_FindProxyForProtocol(LPC
     {
         LPCWSTR end;
 
-        if (!(end = wcschr(ptr, ' ')))
-            end = ptr + lstrlenW(ptr);
-        if (!wcschr(ptr, '='))
+        if (!(end = strchrW(ptr, ' ')))
+            end = ptr + strlenW(ptr);
+        if (!strchrW(ptr, '='))
         {
             ret = heap_strndupW(ptr, end - ptr);
             TRACE("found proxy for %s: %s\n", debugstr_w(proto), debugstr_w(ret));
@@ -507,7 +510,7 @@ static BOOL parse_proxy_url( proxyinfo_t
         return TRUE;
     }
     if (!(info->proxy = heap_alloc( (uc.dwHostNameLength + 12) * sizeof(WCHAR) ))) return FALSE;
-    swprintf( info->proxy, uc.dwHostNameLength + 12, fmt, uc.dwHostNameLength, uc.lpszHostName, uc.nPort );
+    sprintfW( info->proxy, fmt, uc.dwHostNameLength, uc.lpszHostName, uc.nPort );
 
     if (!uc.dwUserNameLength) info->proxyUsername = NULL;
     else if (!(info->proxyUsername = heap_strndupW( uc.lpszUserName, uc.dwUserNameLength )))
@@ -590,13 +593,13 @@ static LONG INTERNET_LoadProxySettings(
             RegQueryValueExW( key, szProxyServer, NULL, &type, (BYTE*)szProxy, &len );
 
             /* find the http proxy, and strip away everything else */
-            p = wcsstr( szProxy, szHttp );
+            p = strstrW( szProxy, szHttp );
             if (p)
             {
                 p += lstrlenW( szHttp );
                 lstrcpyW( szProxy, p );
             }
-            p = wcschr( szProxy, ';' );
+            p = strchrW( szProxy, ';' );
             if (p) *p = 0;
 
             FreeProxyInfo( lpwpi );
@@ -823,14 +826,14 @@ static DWORD APPINFO_QueryOption(object_
         bufsize = *size;
 
         if (unicode) {
-            DWORD len = ai->agent ? lstrlenW(ai->agent) : 0;
+            DWORD len = ai->agent ? strlenW(ai->agent) : 0;
 
             *size = (len + 1) * sizeof(WCHAR);
             if(!buffer || bufsize < *size)
                 return ERROR_INSUFFICIENT_BUFFER;
 
             if (ai->agent)
-                lstrcpyW(buffer, ai->agent);
+                strcpyW(buffer, ai->agent);
             else
                 *(WCHAR *)buffer = 0;
             /* If the buffer is copied, the returned length doesn't include
@@ -1619,7 +1622,7 @@ static INTERNET_SCHEME GetInternetScheme
         return INTERNET_SCHEME_UNKNOWN;
 
     for (i = 0; i < ARRAY_SIZE(url_schemes); i++)
-        if (!wcsnicmp(lpszScheme, url_schemes[i], nMaxCmp))
+        if (!strncmpiW(lpszScheme, url_schemes[i], nMaxCmp))
             return INTERNET_SCHEME_FIRST + i;
 
     return INTERNET_SCHEME_UNKNOWN;
@@ -1647,7 +1650,7 @@ BOOL WINAPI InternetCrackUrlW(const WCHA
     LPCWSTR lpszcp = NULL, lpszNetLoc;
 
     TRACE("(%s %u %x %p)\n",
-          lpszUrl ? debugstr_wn(lpszUrl, dwUrlLength ? dwUrlLength : lstrlenW(lpszUrl)) : "(null)",
+          lpszUrl ? debugstr_wn(lpszUrl, dwUrlLength ? dwUrlLength : strlenW(lpszUrl)) : "(null)",
           dwUrlLength, dwFlags, lpUC);
 
     if (!lpszUrl || !*lpszUrl || !lpUC)
@@ -1655,7 +1658,7 @@ BOOL WINAPI InternetCrackUrlW(const WCHA
         SetLastError(ERROR_INVALID_PARAMETER);
         return FALSE;
     }
-    if (!dwUrlLength) dwUrlLength = lstrlenW(lpszUrl);
+    if (!dwUrlLength) dwUrlLength = strlenW(lpszUrl);
 
     if (dwFlags & ICU_DECODE)
     {
@@ -1694,7 +1697,7 @@ BOOL WINAPI InternetCrackUrlW(const WCHA
     /* Determine if the URI is absolute. */
     while (lpszap - lpszUrl < dwUrlLength)
     {
-        if (iswalnum(*lpszap) || *lpszap == '+' || *lpszap == '.' || *lpszap == '-')
+        if (isalnumW(*lpszap) || *lpszap == '+' || *lpszap == '.' || *lpszap == '-')
         {
             lpszap++;
             continue;
@@ -1721,9 +1724,9 @@ BOOL WINAPI InternetCrackUrlW(const WCHA
     lpUC->nPort = INTERNET_INVALID_PORT_NUMBER;
 
     /* Parse <params> */
-    lpszParam = wmemchr(lpszap, '?', dwUrlLength - (lpszap - lpszUrl));
+    lpszParam = memchrW(lpszap, '?', dwUrlLength - (lpszap - lpszUrl));
     if(!lpszParam)
-        lpszParam = wmemchr(lpszap, '#', dwUrlLength - (lpszap - lpszUrl));
+        lpszParam = memchrW(lpszap, '#', dwUrlLength - (lpszap - lpszUrl));
 
     if(!set_url_component(&lpUC->lpszExtraInfo, &lpUC->dwExtraInfoLength,
                           lpszParam, lpszParam ? dwUrlLength-(lpszParam-lpszUrl) : 0))
@@ -1743,7 +1746,7 @@ BOOL WINAPI InternetCrackUrlW(const WCHA
     {
         lpszcp += 2;
 
-        lpszNetLoc = wmemchr(lpszcp, '/', dwUrlLength - (lpszcp - lpszUrl));
+        lpszNetLoc = memchrW(lpszcp, '/', dwUrlLength - (lpszcp - lpszUrl));
         if (lpszParam)
         {
             if (lpszNetLoc)
@@ -1763,7 +1766,7 @@ BOOL WINAPI InternetCrackUrlW(const WCHA
             /* [<user>[<:password>]@]<host>[:<port>] */
             /* First find the user and password if they exist */
 
-            lpszHost = wmemchr(lpszcp, '@', dwUrlLength - (lpszcp - lpszUrl));
+            lpszHost = memchrW(lpszcp, '@', dwUrlLength - (lpszcp - lpszUrl));
             if (lpszHost == NULL || lpszHost > lpszNetLoc)
             {
                 /* username and password not specified. */
@@ -1829,7 +1832,7 @@ BOOL WINAPI InternetCrackUrlW(const WCHA
                     if(!set_url_component(&lpUC->lpszHostName, &lpUC->dwHostNameLength, lpszHost, lpszPort - lpszHost))
                         return FALSE;
                     if (lpszPort != lpszNetLoc)
-                        lpUC->nPort = wcstol(++lpszPort, NULL, 10);
+                        lpUC->nPort = atoiW(++lpszPort);
                     else switch (lpUC->nScheme)
                     {
                     case INTERNET_SCHEME_HTTP:
@@ -1874,7 +1877,7 @@ BOOL WINAPI InternetCrackUrlW(const WCHA
             /* Leave the parameter list in lpszUrlPath.  Strip off any trailing
              * newlines if necessary.
              */
-            LPWSTR lpsznewline = wmemchr(lpszcp, '\n', dwUrlLength - (lpszcp - lpszUrl));
+            LPWSTR lpsznewline = memchrW(lpszcp, '\n', dwUrlLength - (lpszcp - lpszUrl));
             if (lpsznewline != NULL)
                 len = lpsznewline - lpszcp;
             else
@@ -3347,7 +3350,7 @@ BOOL WINAPI InternetTimeFromSystemTimeW(
         return FALSE;
     }
 
-    swprintf( string, size, date,
+    sprintfW( string, date,
               WININET_wkday[time->wDayOfWeek],
               time->wDay,
               WININET_month[time->wMonth - 1],
@@ -3398,13 +3401,15 @@ BOOL WINAPI InternetTimeToSystemTimeW( L
      *  a SYSTEMTIME structure.
      */
 
-    while (*s && !iswalpha( *s )) s++;
+    while (*s && !isalphaW( *s )) s++;
     if (s[0] == '\0' || s[1] == '\0' || s[2] == '\0') return TRUE;
     time->wDayOfWeek = 7;
 
     for (i = 0; i < 7; i++)
     {
-        if (!wcsnicmp( WININET_wkday[i], s, 3 ))
+        if (toupperW( WININET_wkday[i][0] ) == toupperW( s[0] ) &&
+            toupperW( WININET_wkday[i][1] ) == toupperW( s[1] ) &&
+            toupperW( WININET_wkday[i][2] ) == toupperW( s[2] ) )
         {
             time->wDayOfWeek = i;
             break;
@@ -3412,17 +3417,19 @@ BOOL WINAPI InternetTimeToSystemTimeW( L
     }
 
     if (time->wDayOfWeek > 6) return TRUE;
-    while (*s && !iswdigit( *s )) s++;
-    time->wDay = wcstol( s, &end, 10 );
+    while (*s && !isdigitW( *s )) s++;
+    time->wDay = strtolW( s, &end, 10 );
     s = end;
 
-    while (*s && !iswalpha( *s )) s++;
+    while (*s && !isalphaW( *s )) s++;
     if (s[0] == '\0' || s[1] == '\0' || s[2] == '\0') return TRUE;
     time->wMonth = 0;
 
     for (i = 0; i < 12; i++)
     {
-        if (!wcsnicmp( WININET_month[i], s, 3 ))
+        if (toupperW( WININET_month[i][0]) == toupperW( s[0] ) &&
+            toupperW( WININET_month[i][1]) == toupperW( s[1] ) &&
+            toupperW( WININET_month[i][2]) == toupperW( s[2] ) )
         {
             time->wMonth = i + 1;
             break;
@@ -3430,24 +3437,24 @@ BOOL WINAPI InternetTimeToSystemTimeW( L
     }
     if (time->wMonth == 0) return TRUE;
 
-    while (*s && !iswdigit( *s )) s++;
+    while (*s && !isdigitW( *s )) s++;
     if (*s == '\0') return TRUE;
-    time->wYear = wcstol( s, &end, 10 );
+    time->wYear = strtolW( s, &end, 10 );
     s = end;
 
-    while (*s && !iswdigit( *s )) s++;
+    while (*s && !isdigitW( *s )) s++;
     if (*s == '\0') return TRUE;
-    time->wHour = wcstol( s, &end, 10 );
+    time->wHour = strtolW( s, &end, 10 );
     s = end;
 
-    while (*s && !iswdigit( *s )) s++;
+    while (*s && !isdigitW( *s )) s++;
     if (*s == '\0') return TRUE;
-    time->wMinute = wcstol( s, &end, 10 );
+    time->wMinute = strtolW( s, &end, 10 );
     s = end;
 
-    while (*s && !iswdigit( *s )) s++;
+    while (*s && !isdigitW( *s )) s++;
     if (*s == '\0') return TRUE;
-    time->wSecond = wcstol( s, &end, 10 );
+    time->wSecond = strtolW( s, &end, 10 );
     s = end;
 
     time->wMilliseconds = 0;
@@ -3622,7 +3629,7 @@ static HINTERNET INTERNET_InternetOpenUr
     urlComponents.dwPasswordLength = 1;
     urlComponents.dwUrlPathLength = 1;
     urlComponents.dwExtraInfoLength = 1;
-    if(!InternetCrackUrlW(lpszUrl, lstrlenW(lpszUrl), 0, &urlComponents))
+    if(!InternetCrackUrlW(lpszUrl, strlenW(lpszUrl), 0, &urlComponents))
 	return NULL;
 
     if ((urlComponents.nScheme == INTERNET_SCHEME_HTTP || urlComponents.nScheme == INTERNET_SCHEME_HTTPS) &&
@@ -4170,7 +4177,7 @@ BOOL WINAPI InternetCombineUrlW(LPCWSTR
 #define MAX_WORD_DIGITS 5
 
 #define URL_GET_COMP_LENGTH(url, component) ((url)->dw##component##Length ? \
-    (url)->dw##component##Length : lstrlenW((url)->lpsz##component))
+    (url)->dw##component##Length : strlenW((url)->lpsz##component))
 #define URL_GET_COMP_LENGTHA(url, component) ((url)->dw##component##Length ? \
     (url)->dw##component##Length : strlen((url)->lpsz##component))
 
@@ -4242,7 +4249,7 @@ static BOOL calc_url_length(LPURL_COMPON
         if (nScheme == INTERNET_SCHEME_DEFAULT)
             nScheme = INTERNET_SCHEME_HTTP;
         scheme = INTERNET_GetSchemeString(nScheme);
-        *lpdwUrlLength += lstrlenW(scheme);
+        *lpdwUrlLength += strlenW(scheme);
     }
 
     (*lpdwUrlLength)++; /* ':' */
@@ -4433,7 +4440,6 @@ BOOL WINAPI InternetCreateUrlW(LPURL_COM
 {
     DWORD dwLen;
     INTERNET_SCHEME nScheme;
-    WCHAR *start = lpszUrl;
 
     static const WCHAR slashSlashW[] = {'/','/'};
     static const WCHAR fmtW[] = {'%','u',0};
@@ -4478,7 +4484,7 @@ BOOL WINAPI InternetCreateUrlW(LPURL_COM
             nScheme = INTERNET_SCHEME_HTTP;
 
         scheme = INTERNET_GetSchemeString(nScheme);
-        dwLen = lstrlenW(scheme);
+        dwLen = strlenW(scheme);
         memcpy(lpszUrl, scheme, dwLen * sizeof(WCHAR));
         lpszUrl += dwLen;
     }
@@ -4523,7 +4529,7 @@ BOOL WINAPI InternetCreateUrlW(LPURL_COM
         {
             *lpszUrl = ':';
             lpszUrl++;
-            lpszUrl += swprintf(lpszUrl, *lpdwUrlLength - (lpszUrl - start), fmtW, lpUrlComponents->nPort);
+            lpszUrl += sprintfW(lpszUrl, fmtW, lpUrlComponents->nPort);
         }
 
         /* add slash between hostname and path if necessary */
--- a/dlls/wininet/internet.h
+++ b/dlls/wininet/internet.h
@@ -23,6 +23,7 @@
 #ifndef _WINE_INTERNET_H_
 #define _WINE_INTERNET_H_
 
+#include "wine/unicode.h"
 #include "wine/heap.h"
 #include "wine/list.h"
 
@@ -101,7 +102,7 @@ static inline LPWSTR heap_strdupW(LPCWST
     if(str) {
         DWORD size;
 
-        size = (lstrlenW(str)+1)*sizeof(WCHAR);
+        size = (strlenW(str)+1)*sizeof(WCHAR);
         ret = heap_alloc(size);
         if(ret)
             memcpy(ret, str, size);
@@ -208,7 +209,7 @@ static inline substr_t substr(const WCHA
 
 static inline substr_t substrz(const WCHAR *str)
 {
-    return substr(str, lstrlenW(str));
+    return substr(str, strlenW(str));
 }
 
 static inline void WININET_find_data_WtoA(LPWIN32_FIND_DATAW dataW, LPWIN32_FIND_DATAA dataA)
--- a/dlls/wininet/netconnection.c
+++ b/dlls/wininet/netconnection.c
@@ -32,6 +32,7 @@
 #include <stdio.h>
 #include <assert.h>
 
+#include "wine/library.h"
 #include "windef.h"
 #include "winbase.h"
 #include "wininet.h"
--- a/dlls/wininet/urlcache.c
+++ b/dlls/wininet/urlcache.c
@@ -45,6 +45,8 @@
 #include "shellapi.h"
 
 #include "internet.h"
+
+#include "wine/unicode.h"
 #include "wine/debug.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(wininet);
@@ -484,8 +486,8 @@ static DWORD cache_container_set_size(ca
     urlcache_create_hash_table(header, NULL, &hashtable_entry);
 
     /* Last step - create the directories */
-    lstrcpyW(dir_path, container->path);
-    dir_name = dir_path + lstrlenW(dir_path);
+    strcpyW(dir_path, container->path);
+    dir_name = dir_path + strlenW(dir_path);
     dir_name[8] = 0;
 
     GetSystemTimeAsFileTime(&ft);
@@ -609,8 +611,8 @@ static DWORD cache_container_open_index(
         return ERROR_SUCCESS;
     }
 
-    lstrcpyW(index_path, container->path);
-    lstrcatW(index_path, index_dat);
+    strcpyW(index_path, container->path);
+    strcatW(index_path, index_dat);
 
     file = CreateFileW(index_path, GENERIC_READ|GENERIC_WRITE, FILE_SHARE_READ|FILE_SHARE_WRITE, NULL, OPEN_ALWAYS, 0, NULL);
     if(file == INVALID_HANDLE_VALUE) {
@@ -777,8 +779,8 @@ static void cache_containers_init(void)
             ERR("Couldn't get path for default container %u\n", i);
             continue;
         }
-        path_len = lstrlenW(wszCachePath);
-        suffix_len = lstrlenW(DefaultContainerData[i].shpath_suffix);
+        path_len = strlenW(wszCachePath);
+        suffix_len = strlenW(DefaultContainerData[i].shpath_suffix);
 
         if (path_len + suffix_len + 2 > MAX_PATH)
         {
@@ -789,7 +791,7 @@ static void cache_containers_init(void)
         wszCachePath[path_len] = '\\';
         wszCachePath[path_len+1] = 0;
 
-        lstrcpyW(wszMutexName, wszCachePath);
+        strcpyW(wszMutexName, wszCachePath);
         
         if (suffix_len)
         {
@@ -982,7 +984,7 @@ static BOOL urlcache_create_file_pathW(
     BOOL trunc_name)
 {
     LONG nRequired;
-    int path_len = lstrlenW(pContainer->path);
+    int path_len = strlenW(pContainer->path);
     int file_name_len = MultiByteToWideChar(CP_ACP, 0, szLocalFileName, -1, NULL, 0);
     if (Directory!=CACHE_CONTAINER_NO_SUBDIR && Directory>=pHeader->dirs_no)
     {
@@ -1720,10 +1722,10 @@ static BOOL cache_container_delete_dir(L
     SHFILEOPSTRUCTW shfos;
     int ret;
 
-    path_len = lstrlenW(lpszPath);
+    path_len = strlenW(lpszPath);
     if (path_len >= MAX_PATH)
         return FALSE;
-    lstrcpyW(path, lpszPath);
+    strcpyW(path, lpszPath);
     path[path_len + 1] = 0;  /* double-NUL-terminate path */
 
     shfos.hwnd = NULL;
@@ -2329,7 +2331,7 @@ static DWORD urlcache_rate_entry(entry_u
     return rating;
 }
 
-static int __cdecl dword_cmp(const void *p1, const void *p2)
+static int dword_cmp(const void *p1, const void *p2)
 {
     return *(const DWORD*)p1 - *(const DWORD*)p2;
 }
@@ -2365,7 +2367,7 @@ BOOL WINAPI FreeUrlCacheSpaceW(LPCWSTR c
     }
 
     if(cache_path) {
-        path_len = lstrlenW(cache_path);
+        path_len = strlenW(cache_path);
         if(cache_path[path_len-1] == '\\')
             path_len--;
     }else {
@@ -2377,7 +2379,7 @@ BOOL WINAPI FreeUrlCacheSpaceW(LPCWSTR c
         {
             /* When cache_path==NULL only clean Temporary Internet Files */
             if((!path_len && container->cache_prefix[0]==0) ||
-                    (path_len && !wcsnicmp(container->path, cache_path, path_len) &&
+                    (path_len && !strncmpiW(container->path, cache_path, path_len) &&
                      (container->path[path_len]=='\0' || container->path[path_len]=='\\')))
             {
                 BOOL ret_del;
@@ -2410,7 +2412,7 @@ BOOL WINAPI FreeUrlCacheSpaceW(LPCWSTR c
         FILETIME cur_time;
 
         if((path_len || container->cache_prefix[0]!=0) &&
-                (!path_len || wcsnicmp(container->path, cache_path, path_len) ||
+                (!path_len || strncmpiW(container->path, cache_path, path_len) ||
                  (container->path[path_len]!='\0' && container->path[path_len]!='\\')))
             continue;
 
@@ -2745,7 +2747,7 @@ static BOOL urlcache_entry_create(const
 
     /* Try to generate random name */
     GetSystemTimeAsFileTime(&ft);
-    lstrcpyW(full_path+full_path_len+8, extW);
+    strcpyW(full_path+full_path_len+8, extW);
 
     for(i=0; i<255; i++) {
         int j;
@@ -2901,7 +2903,7 @@ static BOOL urlcache_entry_commit(const
     if(file_name) {
         BOOL bFound = FALSE;
 
-        if(wcsncmp(file_name, container->path, lstrlenW(container->path))) {
+        if(strncmpW(file_name, container->path, lstrlenW(container->path))) {
             ERR("path %s must begin with cache content path %s\n", debugstr_w(file_name), debugstr_w(container->path));
             cache_container_unlock_index(container, header);
             SetLastError(ERROR_INVALID_PARAMETER);
--- a/dlls/wininet/utility.c
+++ b/dlls/wininet/utility.c
@@ -46,7 +46,7 @@ time_t ConvertTimeString(LPCWSTR asctime
     WCHAR tmpChar[TIME_STRING_LEN];
     WCHAR *tmpChar2;
     struct tm t;
-    int timelen = lstrlenW(asctime);
+    int timelen = strlenW(asctime);
 
     if(!timelen)
         return 0;
@@ -56,7 +56,7 @@ time_t ConvertTimeString(LPCWSTR asctime
     lstrcpynW(tmpChar, asctime, TIME_STRING_LEN);
 
     /* Assert that the string is the expected length */
-    if (lstrlenW(asctime) >= TIME_STRING_LEN) FIXME("\n");
+    if (strlenW(asctime) >= TIME_STRING_LEN) FIXME("\n");
 
     /* Convert a time such as 'Mon, 15 Nov 1999 16:09:35 GMT' into a SYSTEMTIME structure
      * We assume the time is in this format
@@ -71,11 +71,11 @@ time_t ConvertTimeString(LPCWSTR asctime
     tmpChar[25]='\0';
 
     memset( &t, 0, sizeof(t) );
-    t.tm_year = wcstol(tmpChar+12, NULL, 10) - 1900;
-    t.tm_mday = wcstol(tmpChar+5, NULL, 10);
-    t.tm_hour = wcstol(tmpChar+17, NULL, 10);
-    t.tm_min = wcstol(tmpChar+20, NULL, 10);
-    t.tm_sec = wcstol(tmpChar+23, NULL, 10);
+    t.tm_year = atoiW(tmpChar+12) - 1900;
+    t.tm_mday = atoiW(tmpChar+5);
+    t.tm_hour = atoiW(tmpChar+17);
+    t.tm_min = atoiW(tmpChar+20);
+    t.tm_sec = atoiW(tmpChar+23);
 
     /* and month */
     tmpChar2 = tmpChar + 8;
