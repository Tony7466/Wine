description: fix incorrect format strings in vkd3d
author: Michael Gilbert <mgilbert@debian.org>

--- a/libs/vkd3d/include/private/vkd3d_memory.h
+++ b/libs/vkd3d/include/private/vkd3d_memory.h
@@ -37,7 +37,7 @@ static inline void *vkd3d_malloc(size_t
 static inline void *vkd3d_realloc(void *ptr, size_t size)
 {
     if (!(ptr = realloc(ptr, size)))
-        ERR("Out of memory, size %zu.\n", size);
+        ERR("Out of memory, size %u.\n", size);
     return ptr;
 }
 
--- a/libs/vkd3d/libs/vkd3d/vkd3d_main.c
+++ b/libs/vkd3d/libs/vkd3d/vkd3d_main.c
@@ -60,7 +60,7 @@ HRESULT vkd3d_create_device(const struct
     }
     else if (FAILED(hr = vkd3d_create_instance(create_info->instance_create_info, &instance)))
     {
-        WARN("Failed to create instance, hr %#x.\n", hr);
+        WARN("Failed to create instance, hr %#lx.\n", hr);
         return E_FAIL;
     }
 
@@ -125,7 +125,7 @@ static ULONG STDMETHODCALLTYPE d3d12_roo
     struct d3d12_root_signature_deserializer *deserializer = impl_from_ID3D12RootSignatureDeserializer(iface);
     ULONG refcount = InterlockedIncrement(&deserializer->refcount);
 
-    TRACE("%p increasing refcount to %u.\n", deserializer, refcount);
+    TRACE("%p increasing refcount to %lu.\n", deserializer, refcount);
 
     return refcount;
 }
@@ -135,7 +135,7 @@ static ULONG STDMETHODCALLTYPE d3d12_roo
     struct d3d12_root_signature_deserializer *deserializer = impl_from_ID3D12RootSignatureDeserializer(iface);
     ULONG refcount = InterlockedDecrement(&deserializer->refcount);
 
-    TRACE("%p decreasing refcount to %u.\n", deserializer, refcount);
+    TRACE("%p decreasing refcount to %lu.\n", deserializer, refcount);
 
     if (!refcount)
     {
@@ -286,7 +286,7 @@ static ULONG STDMETHODCALLTYPE d3d12_ver
     struct d3d12_versioned_root_signature_deserializer *deserializer = impl_from_ID3D12VersionedRootSignatureDeserializer(iface);
     ULONG refcount = InterlockedIncrement(&deserializer->refcount);
 
-    TRACE("%p increasing refcount to %u.\n", deserializer, refcount);
+    TRACE("%p increasing refcount to %lu.\n", deserializer, refcount);
 
     return refcount;
 }
@@ -296,7 +296,7 @@ static ULONG STDMETHODCALLTYPE d3d12_ver
     struct d3d12_versioned_root_signature_deserializer *deserializer = impl_from_ID3D12VersionedRootSignatureDeserializer(iface);
     ULONG refcount = InterlockedDecrement(&deserializer->refcount);
 
-    TRACE("%p decreasing refcount to %u.\n", deserializer, refcount);
+    TRACE("%p decreasing refcount to %lu.\n", deserializer, refcount);
 
     if (!refcount)
     {
@@ -456,7 +456,7 @@ HRESULT vkd3d_serialize_root_signature(c
         if (error_blob && messages)
         {
             if (FAILED(hr = vkd3d_blob_create(messages, strlen(messages), error_blob)))
-                ERR("Failed to create error blob, hr %#x.\n", hr);
+                ERR("Failed to create error blob, hr %#lx.\n", hr);
         }
         return hresult_from_vkd3d_result(ret);
     }
@@ -464,7 +464,7 @@ HRESULT vkd3d_serialize_root_signature(c
 
     if (FAILED(hr = vkd3d_blob_create((void *)dxbc.code, dxbc.size, blob)))
     {
-        WARN("Failed to create blob object, hr %#x.\n", hr);
+        WARN("Failed to create blob object, hr %#lx.\n", hr);
         vkd3d_shader_free_shader_code(&dxbc);
     }
     return hr;
@@ -497,7 +497,7 @@ HRESULT vkd3d_serialize_versioned_root_s
         if (error_blob && messages)
         {
             if (FAILED(hr = vkd3d_blob_create(messages, strlen(messages), error_blob)))
-                ERR("Failed to create error blob, hr %#x.\n", hr);
+                ERR("Failed to create error blob, hr %#lx.\n", hr);
         }
         return hresult_from_vkd3d_result(ret);
     }
@@ -505,7 +505,7 @@ HRESULT vkd3d_serialize_versioned_root_s
 
     if (FAILED(hr = vkd3d_blob_create((void *)dxbc.code, dxbc.size, blob)))
     {
-        WARN("Failed to create blob object, hr %#x.\n", hr);
+        WARN("Failed to create blob object, hr %#lx.\n", hr);
         vkd3d_shader_free_shader_code(&dxbc);
     }
     return hr;
--- a/libs/vkd3d/libs/vkd3d-common/blob.c
+++ b/libs/vkd3d/libs/vkd3d-common/blob.c
@@ -60,7 +60,7 @@ static ULONG STDMETHODCALLTYPE vkd3d_blo
     struct vkd3d_blob *blob = impl_from_ID3DBlob(iface);
     ULONG refcount = InterlockedIncrement(&blob->refcount);
 
-    TRACE("%p increasing refcount to %u.\n", blob, refcount);
+    TRACE("%p increasing refcount to %lu.\n", blob, refcount);
 
     return refcount;
 }
@@ -70,7 +70,7 @@ static ULONG STDMETHODCALLTYPE vkd3d_blo
     struct vkd3d_blob *blob = impl_from_ID3DBlob(iface);
     ULONG refcount = InterlockedDecrement(&blob->refcount);
 
-    TRACE("%p decreasing refcount to %u.\n", blob, refcount);
+    TRACE("%p decreasing refcount to %lu.\n", blob, refcount);
 
     if (!refcount)
     {
--- a/libs/vkd3d/libs/vkd3d-shader/d3dbc.c
+++ b/libs/vkd3d/libs/vkd3d-shader/d3dbc.c
@@ -970,7 +970,7 @@ static void shader_sm1_read_immconst(str
     {
         vkd3d_shader_parser_error(&sm1->p, VKD3D_SHADER_ERROR_D3DBC_UNEXPECTED_EOF,
                 "Attempted to read a constant definition, but not enough tokens are remaining. "
-                "%zu token(s) available, %u required.", sm1->end - *ptr, count);
+                "%u token(s) available, %u required.", sm1->end - *ptr, count);
         sm1->abort = true;
         return;
     }
@@ -1015,7 +1015,7 @@ static void shader_sm1_read_comment(stru
         if (size > --remaining)
         {
             vkd3d_shader_parser_error(&sm1->p, VKD3D_SHADER_ERROR_D3DBC_UNEXPECTED_EOF,
-                    "Encountered a %u token comment, but only %zu token(s) is/are remaining.",
+                    "Encountered a %u token comment, but only %u token(s) is/are remaining.",
                     size, remaining);
             return;
         }
@@ -1058,7 +1058,7 @@ static void shader_sm1_validate_instruct
     if ((ins->handler_idx == VKD3DSIH_BREAKP || ins->handler_idx == VKD3DSIH_IF) && ins->flags)
     {
         vkd3d_shader_parser_warning(&sm1->p, VKD3D_SHADER_WARNING_D3DBC_IGNORED_INSTRUCTION_FLAGS,
-                "Ignoring unexpected instruction flags %#x.", ins->flags);
+                "Ignoring unexpected instruction flags %#lx.", ins->flags);
         ins->flags = 0;
     }
 }
@@ -1131,7 +1131,7 @@ static void shader_sm1_read_instruction(
     if (*ptr > sm1->end)
     {
         vkd3d_shader_parser_error(&sm1->p, VKD3D_SHADER_ERROR_D3DBC_UNEXPECTED_EOF,
-                "The current instruction ends %zu token(s) past the end of the shader.",
+                "The current instruction ends %u token(s) past the end of the shader.",
                 *ptr - sm1->end);
         goto fail;
     }
@@ -1232,7 +1232,7 @@ static enum vkd3d_result shader_sm1_init
     if (token_count < 2)
     {
         vkd3d_shader_error(message_context, &location, VKD3D_SHADER_ERROR_D3DBC_UNEXPECTED_EOF,
-                "Invalid shader size %zu (token count %zu). At least 2 tokens are required.",
+                "Invalid shader size %u (token count %u). At least 2 tokens are required.",
                 code_size, token_count);
         return VKD3D_ERROR_INVALID_SHADER;
     }
--- a/libs/vkd3d/libs/vkd3d-shader/dxbc.c
+++ b/libs/vkd3d/libs/vkd3d-shader/dxbc.c
@@ -44,7 +44,7 @@ int vkd3d_shader_serialize_dxbc(size_t s
     struct vkd3d_bytecode_buffer buffer = {0};
     uint32_t checksum[4];
 
-    TRACE("section_count %zu, sections %p, dxbc %p, messages %p.\n", section_count, sections, dxbc, messages);
+    TRACE("section_count %u, sections %p, dxbc %p, messages %p.\n", section_count, sections, dxbc, messages);
 
     if (messages)
         *messages = NULL;
@@ -136,7 +136,7 @@ static const char *shader_get_string(con
 
     if (offset >= data_size)
     {
-        WARN("Invalid offset %#x (data size %#lx).\n", offset, (long)data_size);
+        WARN("Invalid offset %#lx (data size %#lx).\n", offset, (long)data_size);
         return NULL;
     }
 
@@ -166,9 +166,9 @@ static int parse_dxbc(const struct vkd3d
 
     if (data_size < VKD3D_DXBC_HEADER_SIZE)
     {
-        WARN("Invalid data size %zu.\n", data_size);
+        WARN("Invalid data size %u.\n", data_size);
         vkd3d_shader_error(message_context, &location, VKD3D_SHADER_ERROR_DXBC_INVALID_SIZE,
-                "DXBC size %zu is smaller than the DXBC header size.", data_size);
+                "DXBC size %u is smaller than the DXBC header size.", data_size);
         return VKD3D_ERROR_INVALID_ARGUMENT;
     }
 
@@ -232,9 +232,9 @@ static int parse_dxbc(const struct vkd3d
 
         if (chunk_offset >= data_size || !require_space(chunk_offset, 2, sizeof(DWORD), data_size))
         {
-            WARN("Invalid chunk offset %#x (data size %zu).\n", chunk_offset, data_size);
+            WARN("Invalid chunk offset %#x (data size %u).\n", chunk_offset, data_size);
             vkd3d_shader_error(message_context, &location, VKD3D_SHADER_ERROR_DXBC_INVALID_CHUNK_OFFSET,
-                    "DXBC chunk %u has invalid offset %#x (data size %#zx).", i, chunk_offset, data_size);
+                    "DXBC chunk %u has invalid offset %#x (data size %#x).", i, chunk_offset, data_size);
             vkd3d_free(sections);
             return VKD3D_ERROR_INVALID_ARGUMENT;
         }
@@ -246,10 +246,10 @@ static int parse_dxbc(const struct vkd3d
 
         if (!require_space(chunk_ptr - data, 1, chunk_size, data_size))
         {
-            WARN("Invalid chunk size %#x (data size %zu, chunk offset %#x).\n",
+            WARN("Invalid chunk size %#x (data size %u, chunk offset %#x).\n",
                     chunk_size, data_size, chunk_offset);
             vkd3d_shader_error(message_context, &location, VKD3D_SHADER_ERROR_DXBC_INVALID_CHUNK_SIZE,
-                    "DXBC chunk %u has invalid size %#x (data size %#zx, chunk offset %#x).",
+                    "DXBC chunk %u has invalid size %#x (data size %#x, chunk offset %#x).",
                     i, chunk_offset, data_size, chunk_offset);
             vkd3d_free(sections);
             return VKD3D_ERROR_INVALID_ARGUMENT;
@@ -307,7 +307,7 @@ int vkd3d_shader_parse_dxbc(const struct
     struct vkd3d_shader_message_context message_context;
     int ret;
 
-    TRACE("dxbc {%p, %zu}, flags %#x, desc %p, messages %p.\n", dxbc->code, dxbc->size, flags, desc, messages);
+    TRACE("dxbc {%p, %u}, flags %#x, desc %p, messages %p.\n", dxbc->code, dxbc->size, flags, desc, messages);
 
     if (messages)
         *messages = NULL;
@@ -361,9 +361,9 @@ static int shader_parse_signature(const
 
     if (!require_space(0, 2, sizeof(uint32_t), section->data.size))
     {
-        WARN("Invalid data size %#zx.\n", section->data.size);
+        WARN("Invalid data size %#x.\n", section->data.size);
         vkd3d_shader_error(message_context, NULL, VKD3D_SHADER_ERROR_DXBC_INVALID_SIGNATURE,
-                "Section size %zu is smaller than the minimum signature header size.\n", section->data.size);
+                "Section size %u is smaller than the minimum signature header size.\n", section->data.size);
         return VKD3D_ERROR_INVALID_ARGUMENT;
     }
 
@@ -384,7 +384,7 @@ static int shader_parse_signature(const
 
     if (!require_space(ptr - data, count, 6 * sizeof(uint32_t), section->data.size))
     {
-        WARN("Invalid count %#x (data size %#zx).\n", count, section->data.size);
+        WARN("Invalid count %#x (data size %#x).\n", count, section->data.size);
         return VKD3D_ERROR_INVALID_ARGUMENT;
     }
 
@@ -411,7 +411,7 @@ static int shader_parse_signature(const
         name_offset = read_u32(&ptr);
         if (!(e[i].semantic_name = shader_get_string(data, section->data.size, name_offset)))
         {
-            WARN("Invalid name offset %#x (data size %#zx).\n", name_offset, section->data.size);
+            WARN("Invalid name offset %#x (data size %#x).\n", name_offset, section->data.size);
             vkd3d_free(e);
             return VKD3D_ERROR_INVALID_ARGUMENT;
         }
@@ -856,7 +856,7 @@ static int shader_parse_root_parameters1
 
     if (!require_space(offset, 3 * count, sizeof(DWORD), context->data_size))
     {
-        WARN("Invalid data size %#x (offset %u, count %u).\n", context->data_size, offset, count);
+        WARN("Invalid data size %#x (offset %u, count %lu).\n", context->data_size, offset, count);
         return VKD3D_ERROR_INVALID_ARGUMENT;
     }
     ptr = &context->data[offset];
@@ -942,7 +942,7 @@ static int shader_parse_root_signature(c
 
     if (!require_space(0, 6, sizeof(uint32_t), data->size))
     {
-        WARN("Invalid data size %#zx.\n", data->size);
+        WARN("Invalid data size %#x.\n", data->size);
         return VKD3D_ERROR_INVALID_ARGUMENT;
     }
 
@@ -1028,7 +1028,7 @@ int vkd3d_shader_parse_root_signature(co
     struct vkd3d_shader_message_context message_context;
     int ret;
 
-    TRACE("dxbc {%p, %zu}, root_signature %p, messages %p.\n", dxbc->code, dxbc->size, root_signature, messages);
+    TRACE("dxbc {%p, %u}, root_signature %p, messages %p.\n", dxbc->code, dxbc->size, root_signature, messages);
 
     memset(root_signature, 0, sizeof(*root_signature));
     if (messages)
--- a/libs/vkd3d/libs/vkd3d-shader/hlsl.c
+++ b/libs/vkd3d/libs/vkd3d-shader/hlsl.c
@@ -2734,7 +2734,7 @@ static void dump_ir_swizzle(struct vkd3d
     {
         vkd3d_string_buffer_printf(buffer, ".");
         for (i = 0; i < swizzle->node.data_type->dimx; ++i)
-            vkd3d_string_buffer_printf(buffer, "_m%u%u", (swizzle->swizzle >> i * 8) & 0xf, (swizzle->swizzle >> (i * 8 + 4)) & 0xf);
+            vkd3d_string_buffer_printf(buffer, "_m%lu%lu", (swizzle->swizzle >> i * 8) & 0xf, (swizzle->swizzle >> (i * 8 + 4)) & 0xf);
     }
     else
     {
--- a/libs/vkd3d/libs/vkd3d-shader/vkd3d_shader_private.h
+++ b/libs/vkd3d/libs/vkd3d-shader/vkd3d_shader_private.h
@@ -1516,7 +1516,7 @@ static inline unsigned int vkd3d_write_m
             return i;
     }
 
-    FIXME("Invalid write mask %#x.\n", write_mask);
+    FIXME("Invalid write mask %#lx.\n", write_mask);
     return 0;
 }
 
--- a/libs/vkd3d/libs/vkd3d-shader/spirv.c
+++ b/libs/vkd3d/libs/vkd3d-shader/spirv.c
@@ -4147,7 +4147,7 @@ static void spirv_compiler_emit_store_ds
     for (i = 0; i < component_count; ++i)
     {
         if (vkd3d_swizzle_get_component(swizzle, component_idx + i))
-            ERR("Invalid swizzle %#x for scalar value, write mask %#x.\n", swizzle, dst->write_mask);
+            ERR("Invalid swizzle %#lx for scalar value, write mask %#lx.\n", swizzle, dst->write_mask);
 
         component_ids[i] = val_id;
     }
@@ -7700,7 +7700,7 @@ static int spirv_compiler_emit_control_f
 
             if (src->swizzle != VKD3D_SHADER_SWIZZLE(X, X, X, X))
             {
-                WARN("Unexpected src swizzle %#x.\n", src->swizzle);
+                WARN("Unexpected src swizzle %#lx.\n", src->swizzle);
                 spirv_compiler_warning(compiler, VKD3D_SHADER_WARNING_SPV_INVALID_SWIZZLE,
                         "The swizzle for a switch case value is not scalar.");
             }
@@ -9072,7 +9072,7 @@ static void spirv_compiler_emit_resinfo(
     else
     {
         if (instruction->flags)
-            FIXME("Unhandled flags %#x.\n", instruction->flags);
+            FIXME("Unhandled flags %#lx.\n", instruction->flags);
         val_id = vkd3d_spirv_build_op_convert_utof(builder, type_id, val_id);
     }
     val_id = spirv_compiler_emit_swizzle(compiler, val_id, VKD3DSP_WRITEMASK_ALL,
@@ -9131,7 +9131,7 @@ static void spirv_compiler_emit_sample_i
     else
     {
         if (instruction->flags)
-            FIXME("Unhandled flags %#x.\n", instruction->flags);
+            FIXME("Unhandled flags %#lx.\n", instruction->flags);
         val_id = vkd3d_spirv_build_op_convert_utof(builder, type_id, val_id);
     }
 
--- a/libs/vkd3d/libs/vkd3d-shader/vkd3d_shader_main.c
+++ b/libs/vkd3d/libs/vkd3d-shader/vkd3d_shader_main.c
@@ -1798,7 +1798,7 @@ int vkd3d_shader_parse_input_signature(c
     struct shader_signature shader_signature;
     int ret;
 
-    TRACE("dxbc {%p, %zu}, signature %p, messages %p.\n", dxbc->code, dxbc->size, signature, messages);
+    TRACE("dxbc {%p, %u}, signature %p, messages %p.\n", dxbc->code, dxbc->size, signature, messages);
 
     if (messages)
         *messages = NULL;
--- a/libs/vkd3d/libs/vkd3d/command.c
+++ b/libs/vkd3d/libs/vkd3d/command.c
@@ -313,7 +313,7 @@ static void vkd3d_wait_for_gpu_fence(str
 
     TRACE("Signaling fence %p value %#"PRIx64".\n", waiting_fence->fence, waiting_fence->value);
     if (FAILED(hr = d3d12_fence_signal(waiting_fence->fence, waiting_fence->value, waiting_fence->u.vk_fence, false)))
-        ERR("Failed to signal D3D12 fence, hr %#x.\n", hr);
+        ERR("Failed to signal D3D12 fence, hr %#lx.\n", hr);
 
     d3d12_fence_decref(waiting_fence->fence);
 
@@ -928,7 +928,7 @@ static ULONG STDMETHODCALLTYPE d3d12_fen
     struct d3d12_fence *fence = impl_from_ID3D12Fence1(iface);
     ULONG refcount = InterlockedIncrement(&fence->refcount);
 
-    TRACE("%p increasing refcount to %u.\n", fence, refcount);
+    TRACE("%p increasing refcount to %lu.\n", fence, refcount);
 
     return refcount;
 }
@@ -943,7 +943,7 @@ static ULONG STDMETHODCALLTYPE d3d12_fen
     struct d3d12_fence *fence = impl_from_ID3D12Fence1(iface);
     ULONG refcount = InterlockedDecrement(&fence->refcount);
 
-    TRACE("%p decreasing refcount to %u.\n", fence, refcount);
+    TRACE("%p decreasing refcount to %lu.\n", fence, refcount);
 
     if (!refcount)
         d3d12_fence_decref(fence);
@@ -1637,7 +1637,7 @@ static ULONG STDMETHODCALLTYPE d3d12_com
     struct d3d12_command_allocator *allocator = impl_from_ID3D12CommandAllocator(iface);
     ULONG refcount = InterlockedIncrement(&allocator->refcount);
 
-    TRACE("%p increasing refcount to %u.\n", allocator, refcount);
+    TRACE("%p increasing refcount to %lu.\n", allocator, refcount);
 
     return refcount;
 }
@@ -1647,7 +1647,7 @@ static ULONG STDMETHODCALLTYPE d3d12_com
     struct d3d12_command_allocator *allocator = impl_from_ID3D12CommandAllocator(iface);
     ULONG refcount = InterlockedDecrement(&allocator->refcount);
 
-    TRACE("%p decreasing refcount to %u.\n", allocator, refcount);
+    TRACE("%p decreasing refcount to %lu.\n", allocator, refcount);
 
     if (!refcount)
     {
@@ -2322,7 +2322,7 @@ static ULONG STDMETHODCALLTYPE d3d12_com
     struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList5(iface);
     ULONG refcount = InterlockedIncrement(&list->refcount);
 
-    TRACE("%p increasing refcount to %u.\n", list, refcount);
+    TRACE("%p increasing refcount to %lu.\n", list, refcount);
 
     return refcount;
 }
@@ -2337,7 +2337,7 @@ static ULONG STDMETHODCALLTYPE d3d12_com
     struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList5(iface);
     ULONG refcount = InterlockedDecrement(&list->refcount);
 
-    TRACE("%p decreasing refcount to %u.\n", list, refcount);
+    TRACE("%p decreasing refcount to %lu.\n", list, refcount);
 
     if (!refcount)
     {
@@ -3701,7 +3701,7 @@ static void d3d12_command_list_copy_inco
             buffer_image_copy.imageExtent.height * buffer_image_copy.imageExtent.depth * layer_count;
     if (FAILED(hr = d3d12_command_list_allocate_transfer_buffer(list, buffer_size, &transfer_buffer)))
     {
-        ERR("Failed to allocate transfer buffer, hr %#x.\n", hr);
+        ERR("Failed to allocate transfer buffer, hr %#lx.\n", hr);
         return;
     }
 
@@ -4930,7 +4930,7 @@ static void STDMETHODCALLTYPE d3d12_comm
 
     if (render_target_descriptor_count > ARRAY_SIZE(list->rtvs))
     {
-        WARN("Descriptor count %u > %zu, ignoring extra descriptors.\n",
+        WARN("Descriptor count %u > %u, ignoring extra descriptors.\n",
                 render_target_descriptor_count, ARRAY_SIZE(list->rtvs));
         render_target_descriptor_count = ARRAY_SIZE(list->rtvs);
     }
@@ -6227,7 +6227,7 @@ static ULONG STDMETHODCALLTYPE d3d12_com
     struct d3d12_command_queue *command_queue = impl_from_ID3D12CommandQueue(iface);
     ULONG refcount = InterlockedIncrement(&command_queue->refcount);
 
-    TRACE("%p increasing refcount to %u.\n", command_queue, refcount);
+    TRACE("%p increasing refcount to %lu.\n", command_queue, refcount);
 
     return refcount;
 }
@@ -6269,7 +6269,7 @@ static ULONG STDMETHODCALLTYPE d3d12_com
     struct d3d12_command_queue *command_queue = impl_from_ID3D12CommandQueue(iface);
     ULONG refcount = InterlockedDecrement(&command_queue->refcount);
 
-    TRACE("%p decreasing refcount to %u.\n", command_queue, refcount);
+    TRACE("%p decreasing refcount to %lu.\n", command_queue, refcount);
 
     if (!refcount)
     {
@@ -6558,7 +6558,7 @@ static void d3d12_command_queue_submit_l
     if (queue->op_queue.count == 1 && !queue->is_flushing)
     {
         if (FAILED(hr = d3d12_command_queue_flush_ops_locked(queue, &flushed_any)))
-            ERR("Cannot flush queue, hr %#x.\n", hr);
+            ERR("Cannot flush queue, hr %#lx.\n", hr);
     }
 }
 
@@ -7172,7 +7172,7 @@ static bool d3d12_command_queue_op_array
 {
     if (!vkd3d_array_reserve((void **)&array->ops, &array->size, array->count + count, sizeof(*array->ops)))
     {
-        ERR("Cannot reserve memory for %zu new ops.\n", count);
+        ERR("Cannot reserve memory for %u new ops.\n", count);
         return false;
     }
 
@@ -7391,7 +7391,7 @@ VkQueue vkd3d_acquire_vk_queue(ID3D12Com
     VkQueue vk_queue = vkd3d_queue_acquire(d3d12_queue->vkd3d_queue);
 
     if (d3d12_queue->op_queue.count)
-        WARN("Acquired command queue %p with %zu remaining ops.\n", d3d12_queue, d3d12_queue->op_queue.count);
+        WARN("Acquired command queue %p with %u remaining ops.\n", d3d12_queue, d3d12_queue->op_queue.count);
     else if (d3d12_queue->is_flushing)
         WARN("Acquired command queue %p which is flushing.\n", d3d12_queue);
 
@@ -7438,7 +7438,7 @@ static ULONG STDMETHODCALLTYPE d3d12_com
     struct d3d12_command_signature *signature = impl_from_ID3D12CommandSignature(iface);
     ULONG refcount = InterlockedIncrement(&signature->refcount);
 
-    TRACE("%p increasing refcount to %u.\n", signature, refcount);
+    TRACE("%p increasing refcount to %lu.\n", signature, refcount);
 
     return refcount;
 }
@@ -7448,7 +7448,7 @@ static ULONG STDMETHODCALLTYPE d3d12_com
     struct d3d12_command_signature *signature = impl_from_ID3D12CommandSignature(iface);
     ULONG refcount = InterlockedDecrement(&signature->refcount);
 
-    TRACE("%p decreasing refcount to %u.\n", signature, refcount);
+    TRACE("%p decreasing refcount to %lu.\n", signature, refcount);
 
     if (!refcount)
         d3d12_command_signature_decref(signature);
--- a/libs/vkd3d/libs/vkd3d/device.c
+++ b/libs/vkd3d/libs/vkd3d/device.c
@@ -549,7 +549,7 @@ static HRESULT vkd3d_instance_init(struc
     }
     if (create_info->wchar_size != 2 && create_info->wchar_size != 4)
     {
-        ERR("Unexpected WCHAR size %zu.\n", create_info->wchar_size);
+        ERR("Unexpected WCHAR size %u.\n", create_info->wchar_size);
         return E_INVALIDARG;
     }
 
@@ -562,7 +562,7 @@ static HRESULT vkd3d_instance_init(struc
 
     if (FAILED(hr = vkd3d_init_vk_global_procs(instance, create_info->pfn_vkGetInstanceProcAddr)))
     {
-        ERR("Failed to initialize Vulkan global procs, hr %#x.\n", hr);
+        ERR("Failed to initialize Vulkan global procs, hr %#lx.\n", hr);
         return hr;
     }
 
@@ -642,7 +642,7 @@ static HRESULT vkd3d_instance_init(struc
 
     if (FAILED(hr = vkd3d_load_vk_instance_procs(&instance->vk_procs, vk_global_procs, vk_instance)))
     {
-        ERR("Failed to load instance procs, hr %#x.\n", hr);
+        ERR("Failed to load instance procs, hr %#lx.\n", hr);
         if (instance->vk_procs.vkDestroyInstance)
             instance->vk_procs.vkDestroyInstance(vk_instance, NULL);
         if (instance->libvulkan)
@@ -720,7 +720,7 @@ ULONG vkd3d_instance_incref(struct vkd3d
 {
     ULONG refcount = InterlockedIncrement(&instance->refcount);
 
-    TRACE("%p increasing refcount to %u.\n", instance, refcount);
+    TRACE("%p increasing refcount to %lu.\n", instance, refcount);
 
     return refcount;
 }
@@ -729,7 +729,7 @@ ULONG vkd3d_instance_decref(struct vkd3d
 {
     ULONG refcount = InterlockedDecrement(&instance->refcount);
 
-    TRACE("%p decreasing refcount to %u.\n", instance, refcount);
+    TRACE("%p decreasing refcount to %lu.\n", instance, refcount);
 
     if (!refcount)
         vkd3d_destroy_instance(instance);
@@ -2028,7 +2028,7 @@ static HRESULT vkd3d_create_vk_device(st
 
     if (FAILED(hr = vkd3d_load_vk_device_procs(&device->vk_procs, vk_procs, vk_device)))
     {
-        ERR("Failed to load device procs, hr %#x.\n", hr);
+        ERR("Failed to load device procs, hr %#lx.\n", hr);
         if (device->vk_procs.vkDestroyDevice)
             device->vk_procs.vkDestroyDevice(vk_device, NULL);
         return hr;
@@ -2038,7 +2038,7 @@ static HRESULT vkd3d_create_vk_device(st
 
     if (FAILED(hr = d3d12_device_create_vkd3d_queues(device, &device_queue_info)))
     {
-        ERR("Failed to create queues, hr %#x.\n", hr);
+        ERR("Failed to create queues, hr %#lx.\n", hr);
         device->vk_procs.vkDestroyDevice(vk_device, NULL);
         return hr;
     }
@@ -2106,7 +2106,7 @@ static D3D12_GPU_VIRTUAL_ADDRESS vkd3d_g
     slab_idx = slab - allocator->slabs;
     address = VKD3D_VA_SLAB_BASE + slab_idx * VKD3D_VA_SLAB_SIZE;
 
-    TRACE("Allocated address %#"PRIx64", slab %u, size %zu.\n", address, slab_idx, aligned_size);
+    TRACE("Allocated address %#"PRIx64", slab %u, size %u.\n", address, slab_idx, aligned_size);
 
     return address;
 }
@@ -2138,7 +2138,7 @@ static D3D12_GPU_VIRTUAL_ADDRESS vkd3d_g
      * only fail once we have exhausted 63 bits of address space. */
     allocator->fallback_floor = base + aligned_size;
 
-    TRACE("Allocated address %#"PRIx64", size %zu.\n", base, aligned_size);
+    TRACE("Allocated address %#"PRIx64", size %u.\n", base, aligned_size);
 
     return base;
 }
@@ -2184,7 +2184,7 @@ static void *vkd3d_gpu_va_allocator_dere
     base_offset -= slab_idx * VKD3D_VA_SLAB_SIZE;
     if (base_offset >= slab->size)
     {
-        ERR("Address %#"PRIx64" is %#"PRIx64" bytes into slab %u of size %zu.\n",
+        ERR("Address %#"PRIx64" is %#"PRIx64" bytes into slab %u of size %u.\n",
                 address, base_offset, slab_idx, slab->size);
         return NULL;
     }
@@ -2490,7 +2490,7 @@ static ULONG STDMETHODCALLTYPE d3d12_dev
     struct d3d12_device *device = impl_from_ID3D12Device5(iface);
     ULONG refcount = InterlockedIncrement(&device->refcount);
 
-    TRACE("%p increasing refcount to %u.\n", device, refcount);
+    TRACE("%p increasing refcount to %lu.\n", device, refcount);
 
     return refcount;
 }
@@ -2500,7 +2500,7 @@ static ULONG STDMETHODCALLTYPE d3d12_dev
     struct d3d12_device *device = impl_from_ID3D12Device5(iface);
     ULONG refcount = InterlockedDecrement(&device->refcount);
 
-    TRACE("%p decreasing refcount to %u.\n", device, refcount);
+    TRACE("%p decreasing refcount to %lu.\n", device, refcount);
 
     if (!refcount)
     {
@@ -3707,7 +3707,7 @@ static HRESULT STDMETHODCALLTYPE d3d12_d
 {
     struct d3d12_device *device = impl_from_ID3D12Device5(iface);
 
-    FIXME("iface %p, object %p, attributes %p, access %#x, name %s, handle %p stub!\n",
+    FIXME("iface %p, object %p, attributes %p, access %#lx, name %s, handle %p stub!\n",
             iface, object, attributes, access, debugstr_w(name, device->wchar_size), handle);
 
     return E_NOTIMPL;
@@ -3727,7 +3727,7 @@ static HRESULT STDMETHODCALLTYPE d3d12_d
 {
     struct d3d12_device *device = impl_from_ID3D12Device5(iface);
 
-    FIXME("iface %p, name %s, access %#x, handle %p stub!\n",
+    FIXME("iface %p, name %s, access %#lx, handle %p stub!\n",
             iface, debugstr_w(name, device->wchar_size), access, handle);
 
     return E_NOTIMPL;
@@ -4354,7 +4354,7 @@ void d3d12_device_mark_as_removed(struct
     va_list args;
 
     va_start(args, message);
-    WARN("Device %p is lost (reason %#x, \"%s\").\n",
+    WARN("Device %p is lost (reason %#lx, \"%s\").\n",
             device, reason, vkd3d_dbg_vsprintf(message, args));
     va_end(args);
 
@@ -4403,7 +4403,7 @@ HRESULT vkd3d_create_thread(struct vkd3d
         thread_data->data = data;
         if (!(thread->handle = CreateThread(NULL, 0, call_thread_main, thread_data, 0, NULL)))
         {
-            ERR("Failed to create thread, error %d.\n", GetLastError());
+            ERR("Failed to create thread, error %ld.\n", GetLastError());
             vkd3d_free(thread_data);
             hr = E_FAIL;
         }
@@ -4412,7 +4412,7 @@ HRESULT vkd3d_create_thread(struct vkd3d
 
         if ((rc = pthread_create(&thread->pthread, NULL, thread_main, data)))
         {
-            ERR("Failed to create thread, error %d.\n", rc);
+            ERR("Failed to create thread, error %ld.\n", rc);
             hr = hresult_from_errno(rc);
         }
 #endif
@@ -4429,7 +4429,7 @@ HRESULT vkd3d_join_thread(struct vkd3d_i
     if (instance->join_thread)
     {
         if (FAILED(hr = instance->join_thread(thread->handle)))
-            ERR("Failed to join thread, hr %#x.\n", hr);
+            ERR("Failed to join thread, hr %#lx.\n", hr);
     }
     else
     {
--- a/libs/vkd3d/libs/vkd3d/resource.c
+++ b/libs/vkd3d/libs/vkd3d/resource.c
@@ -310,7 +310,7 @@ static ULONG STDMETHODCALLTYPE d3d12_hea
     struct d3d12_heap *heap = impl_from_ID3D12Heap(iface);
     ULONG refcount = InterlockedIncrement(&heap->refcount);
 
-    TRACE("%p increasing refcount to %u.\n", heap, refcount);
+    TRACE("%p increasing refcount to %lu.\n", heap, refcount);
 
     assert(!heap->is_private);
 
@@ -347,7 +347,7 @@ static ULONG STDMETHODCALLTYPE d3d12_hea
     struct d3d12_heap *heap = impl_from_ID3D12Heap(iface);
     ULONG refcount = InterlockedDecrement(&heap->refcount);
 
-    TRACE("%p decreasing refcount to %u.\n", heap, refcount);
+    TRACE("%p decreasing refcount to %lu.\n", heap, refcount);
 
     /* A heap must not be destroyed until all contained resources are destroyed. */
     if (!refcount && !heap->resource_count)
@@ -1005,7 +1005,7 @@ static ULONG d3d12_resource_incref(struc
 {
     ULONG refcount = InterlockedIncrement(&resource->internal_refcount);
 
-    TRACE("%p increasing refcount to %u.\n", resource, refcount);
+    TRACE("%p increasing refcount to %lu.\n", resource, refcount);
 
     return refcount;
 }
@@ -1014,7 +1014,7 @@ static ULONG d3d12_resource_decref(struc
 {
     ULONG refcount = InterlockedDecrement(&resource->internal_refcount);
 
-    TRACE("%p decreasing refcount to %u.\n", resource, refcount);
+    TRACE("%p decreasing refcount to %lu.\n", resource, refcount);
 
     if (!refcount)
     {
@@ -1286,7 +1286,7 @@ static ULONG STDMETHODCALLTYPE d3d12_res
     struct d3d12_resource *resource = impl_from_ID3D12Resource1(iface);
     ULONG refcount = InterlockedIncrement(&resource->refcount);
 
-    TRACE("%p increasing refcount to %u.\n", resource, refcount);
+    TRACE("%p increasing refcount to %lu.\n", resource, refcount);
 
     if (refcount == 1)
     {
@@ -1304,7 +1304,7 @@ static ULONG STDMETHODCALLTYPE d3d12_res
     struct d3d12_resource *resource = impl_from_ID3D12Resource1(iface);
     ULONG refcount = InterlockedDecrement(&resource->refcount);
 
-    TRACE("%p decreasing refcount to %u.\n", resource, refcount);
+    TRACE("%p decreasing refcount to %lu.\n", resource, refcount);
 
     if (!refcount)
     {
@@ -3968,7 +3968,7 @@ static ULONG STDMETHODCALLTYPE d3d12_des
     struct d3d12_descriptor_heap *heap = impl_from_ID3D12DescriptorHeap(iface);
     ULONG refcount = InterlockedIncrement(&heap->refcount);
 
-    TRACE("%p increasing refcount to %u.\n", heap, refcount);
+    TRACE("%p increasing refcount to %lu.\n", heap, refcount);
 
     return refcount;
 }
@@ -3978,7 +3978,7 @@ static ULONG STDMETHODCALLTYPE d3d12_des
     struct d3d12_descriptor_heap *heap = impl_from_ID3D12DescriptorHeap(iface);
     ULONG refcount = InterlockedDecrement(&heap->refcount);
 
-    TRACE("%p decreasing refcount to %u.\n", heap, refcount);
+    TRACE("%p decreasing refcount to %lu.\n", heap, refcount);
 
     if (!refcount)
     {
@@ -4296,7 +4296,7 @@ HRESULT d3d12_descriptor_heap_create(str
     max_descriptor_count = (~(size_t)0 - sizeof(*object)) / descriptor_size;
     if (desc->NumDescriptors > max_descriptor_count)
     {
-        WARN("Invalid descriptor count %u (max %zu).\n", desc->NumDescriptors, max_descriptor_count);
+        WARN("Invalid descriptor count %u (max %u).\n", desc->NumDescriptors, max_descriptor_count);
         return E_OUTOFMEMORY;
     }
 
@@ -4366,7 +4366,7 @@ static ULONG STDMETHODCALLTYPE d3d12_que
     struct d3d12_query_heap *heap = impl_from_ID3D12QueryHeap(iface);
     ULONG refcount = InterlockedIncrement(&heap->refcount);
 
-    TRACE("%p increasing refcount to %u.\n", heap, refcount);
+    TRACE("%p increasing refcount to %lu.\n", heap, refcount);
 
     return refcount;
 }
@@ -4376,7 +4376,7 @@ static ULONG STDMETHODCALLTYPE d3d12_que
     struct d3d12_query_heap *heap = impl_from_ID3D12QueryHeap(iface);
     ULONG refcount = InterlockedDecrement(&heap->refcount);
 
-    TRACE("%p decreasing refcount to %u.\n", heap, refcount);
+    TRACE("%p decreasing refcount to %lu.\n", heap, refcount);
 
     if (!refcount)
     {
@@ -4858,7 +4858,7 @@ HRESULT vkd3d_init_null_resources(struct
     return vkd3d_init_null_resources_data(null_resources, device);
 
 fail:
-    ERR("Failed to initialize NULL resources, hr %#x.\n", hr);
+    ERR("Failed to initialize NULL resources, hr %#lx.\n", hr);
     vkd3d_destroy_null_resources(null_resources, device);
     return hr;
 }
--- a/libs/vkd3d/libs/vkd3d/state.c
+++ b/libs/vkd3d/libs/vkd3d/state.c
@@ -54,7 +54,7 @@ static ULONG STDMETHODCALLTYPE d3d12_roo
     struct d3d12_root_signature *root_signature = impl_from_ID3D12RootSignature(iface);
     ULONG refcount = InterlockedIncrement(&root_signature->refcount);
 
-    TRACE("%p increasing refcount to %u.\n", root_signature, refcount);
+    TRACE("%p increasing refcount to %lu.\n", root_signature, refcount);
 
     return refcount;
 }
@@ -112,7 +112,7 @@ static ULONG STDMETHODCALLTYPE d3d12_roo
     struct d3d12_root_signature *root_signature = impl_from_ID3D12RootSignature(iface);
     ULONG refcount = InterlockedDecrement(&root_signature->refcount);
 
-    TRACE("%p decreasing refcount to %u.\n", root_signature, refcount);
+    TRACE("%p decreasing refcount to %lu.\n", root_signature, refcount);
 
     if (!refcount)
     {
@@ -1414,7 +1414,7 @@ static HRESULT d3d12_root_signature_init
         return hr;
     if (info.cost > D3D12_MAX_ROOT_COST)
     {
-        WARN("Root signature cost %zu exceeds maximum allowed cost.\n", info.cost);
+        WARN("Root signature cost %u exceeds maximum allowed cost.\n", info.cost);
         return E_INVALIDARG;
     }
 
@@ -1967,7 +1967,7 @@ static ULONG STDMETHODCALLTYPE d3d12_pip
     struct d3d12_pipeline_state *state = impl_from_ID3D12PipelineState(iface);
     ULONG refcount = InterlockedIncrement(&state->refcount);
 
-    TRACE("%p increasing refcount to %u.\n", state, refcount);
+    TRACE("%p increasing refcount to %lu.\n", state, refcount);
 
     return refcount;
 }
@@ -2010,7 +2010,7 @@ static ULONG STDMETHODCALLTYPE d3d12_pip
     struct d3d12_pipeline_state *state = impl_from_ID3D12PipelineState(iface);
     ULONG refcount = InterlockedDecrement(&state->refcount);
 
-    TRACE("%p decreasing refcount to %u.\n", state, refcount);
+    TRACE("%p decreasing refcount to %lu.\n", state, refcount);
 
     if (!refcount)
     {
@@ -2240,7 +2240,7 @@ static HRESULT vkd3d_create_compute_pipe
     VK_CALL(vkDestroyShaderModule(device->vk_device, pipeline_info.stage.module, NULL));
     if (vr < 0)
     {
-        WARN("Failed to create Vulkan compute pipeline, hr %#x.\n", hr);
+        WARN("Failed to create Vulkan compute pipeline, hr %#lx.\n", hr);
         return hresult_from_vk_result(vr);
     }
 
@@ -2368,7 +2368,7 @@ static HRESULT d3d12_pipeline_state_find
     }
 
     if (FAILED(hr = d3d12_pipeline_state_init_uav_counters(state, device, root_signature, &shader_info, stage_flags)))
-        WARN("Failed to create descriptor set layout for UAV counters, hr %#x.\n", hr);
+        WARN("Failed to create descriptor set layout for UAV counters, hr %#lx.\n", hr);
 
     vkd3d_shader_free_scan_descriptor_info(&shader_info);
 
@@ -2442,7 +2442,7 @@ static HRESULT d3d12_pipeline_state_init
     if (FAILED(hr = vkd3d_create_compute_pipeline(device, &desc->cs, &shader_interface,
             vk_pipeline_layout, &state->u.compute.vk_pipeline)))
     {
-        WARN("Failed to create Vulkan compute pipeline, hr %#x.\n", hr);
+        WARN("Failed to create Vulkan compute pipeline, hr %#lx.\n", hr);
         d3d12_pipeline_uav_counter_state_cleanup(&state->uav_counters, device);
         return hr;
     }
@@ -3010,7 +3010,7 @@ static HRESULT d3d12_pipeline_state_init
     rt_count = desc->rtv_formats.NumRenderTargets;
     if (rt_count > ARRAY_SIZE(graphics->blend_attachments))
     {
-        FIXME("NumRenderTargets %zu > %zu, ignoring extra formats.\n",
+        FIXME("NumRenderTargets %u > %u, ignoring extra formats.\n",
                 rt_count, ARRAY_SIZE(graphics->blend_attachments));
         rt_count = ARRAY_SIZE(graphics->blend_attachments);
     }
@@ -3284,7 +3284,7 @@ static HRESULT d3d12_pipeline_state_init
     graphics->attribute_count = desc->input_layout.NumElements;
     if (graphics->attribute_count > ARRAY_SIZE(graphics->attributes))
     {
-        FIXME("InputLayout.NumElements %zu > %zu, ignoring extra elements.\n",
+        FIXME("InputLayout.NumElements %u > %u, ignoring extra elements.\n",
                 graphics->attribute_count, ARRAY_SIZE(graphics->attributes));
         graphics->attribute_count = ARRAY_SIZE(graphics->attributes);
     }
@@ -3996,14 +3996,14 @@ HRESULT vkd3d_uav_clear_state_init(struc
         if (FAILED(hr = vkd3d_create_descriptor_set_layout(device, 0,
                 1, false, &set_binding, set_layouts[i].set_layout)))
         {
-            ERR("Failed to create descriptor set layout %u, hr %#x.\n", i, hr);
+            ERR("Failed to create descriptor set layout %u, hr %#lx.\n", i, hr);
             goto fail;
         }
 
         if (FAILED(hr = vkd3d_create_pipeline_layout(device, 1, set_layouts[i].set_layout,
                 1, &push_constant_range, set_layouts[i].pipeline_layout)))
         {
-            ERR("Failed to create pipeline layout %u, hr %#x.\n", i, hr);
+            ERR("Failed to create pipeline layout %u, hr %#lx.\n", i, hr);
             goto fail;
         }
     }
@@ -4041,7 +4041,7 @@ HRESULT vkd3d_uav_clear_state_init(struc
         vkd3d_shader_free_shader_code(&dxbc);
         if (FAILED(hr))
         {
-            ERR("Failed to create compute pipeline %u, hr %#x.\n", i, hr);
+            ERR("Failed to create compute pipeline %u, hr %#lx.\n", i, hr);
             goto fail;
         }
     }
--- a/libs/vkd3d/libs/vkd3d/vkd3d_private.h
+++ b/libs/vkd3d/libs/vkd3d/vkd3d_private.h
@@ -248,7 +248,7 @@ static inline void vkd3d_cond_broadcast(
 static inline void vkd3d_cond_wait(struct vkd3d_cond *cond, struct vkd3d_mutex *lock)
 {
     if (!SleepConditionVariableCS(&cond->cond, &lock->lock, INFINITE))
-        ERR("Could not sleep on the condition variable, error %u.\n", GetLastError());
+        ERR("Could not sleep on the condition variable, error %lu.\n", GetLastError());
 }
 
 static inline void vkd3d_cond_destroy(struct vkd3d_cond *cond)
--- a/libs/vkd3d/libs/vkd3d-shader/preproc.y
+++ b/libs/vkd3d/libs/vkd3d-shader/preproc.y
@@ -101,7 +101,7 @@ bool preproc_add_macro(struct preproc_ct
         preproc_free_macro(macro);
     }
 
-    TRACE("Defining new macro %s with %zu arguments.\n", debugstr_a(name), arg_count);
+    TRACE("Defining new macro %s with %u arguments.\n", debugstr_a(name), arg_count);
 
     if (!(macro = vkd3d_malloc(sizeof(*macro))))
         return false;
--- a/libs/vkd3d/libs/vkd3d-shader/preproc.l
+++ b/libs/vkd3d/libs/vkd3d-shader/preproc.l
@@ -260,7 +260,7 @@ static void preproc_pop_buffer(struct pr
         yy_delete_buffer(exp->buffer.lexer_buffer, ctx->scanner);
 
         --ctx->expansion_count;
-        TRACE("Expansion stack size is now %zu.\n", ctx->expansion_count);
+        TRACE("Expansion stack size is now %u.\n", ctx->expansion_count);
     }
     else
     {
@@ -282,7 +282,7 @@ static void preproc_pop_buffer(struct pr
         yy_delete_buffer(file->buffer.lexer_buffer, ctx->scanner);
 
         --ctx->file_count;
-        TRACE("File stack size is now %zu.\n", ctx->file_count);
+        TRACE("File stack size is now %u.\n", ctx->file_count);
     }
 
     if (ctx->expansion_count)
@@ -343,7 +343,7 @@ static bool preproc_push_expansion(struc
     exp->buffer.lexer_buffer = yy_scan_bytes(text->text.buffer, text->text.content_size, ctx->scanner);
     exp->buffer.location = text->location;
     exp->macro = macro;
-    TRACE("Expansion stack size is now %zu.\n", ctx->expansion_count);
+    TRACE("Expansion stack size is now %u.\n", ctx->expansion_count);
     return true;
 }
 
@@ -706,7 +706,7 @@ int yylex(YYSTYPE *lval, YYLTYPE *lloc,
                             else
                             {
                                 preproc_warning(ctx, lloc, VKD3D_SHADER_WARNING_PP_ARGUMENT_COUNT_MISMATCH,
-                                        "Wrong number of arguments to macro \"%s\": expected %zu, got %zu.",
+                                        "Wrong number of arguments to macro \"%s\": expected %u, got %u.",
                                         func_state->macro->name, func_state->macro->arg_count, func_state->arg_count);
 
                                 if (ctx->current_directive)
@@ -771,7 +771,7 @@ bool preproc_push_include(struct preproc
     file->buffer.location.source_name = file->filename;
     file->buffer.location.line = 1;
     file->buffer.location.column = 1;
-    TRACE("File stack size is now %zu.\n", ctx->file_count);
+    TRACE("File stack size is now %u.\n", ctx->file_count);
     ctx->last_was_newline = true;
     return true;
 }
--- a/libs/vkd3d/libs/vkd3d-shader/d3d_asm.c
+++ b/libs/vkd3d/libs/vkd3d-shader/d3d_asm.c
@@ -1384,7 +1384,7 @@ static void shader_dump_ins_modifiers(st
         case 1: shader_addline(buffer, "_x2"); break;
         case 2: shader_addline(buffer, "_x4"); break;
         case 3: shader_addline(buffer, "_x8"); break;
-        default: shader_addline(buffer, "_unhandled_shift(%d)", dst->shift); break;
+        default: shader_addline(buffer, "_unhandled_shift(%ld)", dst->shift); break;
     }
 
     if (mmask & VKD3DSPDM_SATURATE)         shader_addline(buffer, "_sat");
@@ -1531,7 +1531,7 @@ static void shader_dump_instruction_flag
             {
                 case VKD3D_SHADER_CONDITIONAL_OP_NZ: shader_addline(buffer, "_nz"); break;
                 case VKD3D_SHADER_CONDITIONAL_OP_Z:  shader_addline(buffer, "_z"); break;
-                default: shader_addline(buffer, "_unrecognized(%#x)", ins->flags); break;
+                default: shader_addline(buffer, "_unrecognized(%#lx)", ins->flags); break;
             }
             break;
 
@@ -1545,7 +1545,7 @@ static void shader_dump_instruction_flag
                 case VKD3D_SHADER_REL_OP_LT: shader_addline(buffer, "_lt"); break;
                 case VKD3D_SHADER_REL_OP_NE: shader_addline(buffer, "_ne"); break;
                 case VKD3D_SHADER_REL_OP_LE: shader_addline(buffer, "_le"); break;
-                default: shader_addline(buffer, "_(%u)", ins->flags);
+                default: shader_addline(buffer, "_(%lu)", ins->flags);
             }
             break;
 
@@ -1555,7 +1555,7 @@ static void shader_dump_instruction_flag
                 case VKD3DSI_NONE: break;
                 case VKD3DSI_RESINFO_RCP_FLOAT: shader_addline(buffer, "_rcpFloat"); break;
                 case VKD3DSI_RESINFO_UINT: shader_addline(buffer, "_uint"); break;
-                default: shader_addline(buffer, "_unrecognized(%#x)", ins->flags);
+                default: shader_addline(buffer, "_unrecognized(%#lx)", ins->flags);
             }
             break;
 
@@ -1564,7 +1564,7 @@ static void shader_dump_instruction_flag
             {
                 case VKD3DSI_NONE: break;
                 case VKD3DSI_SAMPLE_INFO_UINT: shader_addline(buffer, "_uint"); break;
-                default: shader_addline(buffer, "_unrecognized(%#x)", ins->flags);
+                default: shader_addline(buffer, "_unrecognized(%#lx)", ins->flags);
             }
             break;
 
--- a/libs/vkd3d/libs/vkd3d-shader/dxil.c
+++ b/libs/vkd3d/libs/vkd3d-shader/dxil.c
@@ -1356,13 +1356,13 @@ static enum vkd3d_result sm6_parser_type
 
                 if (!(type->u.array.count = record->operands[0]))
                 {
-                    TRACE("Setting unbounded for type %zu.\n", type_index);
+                    TRACE("Setting unbounded for type %u.\n", type_index);
                     type->u.array.count = UINT_MAX;
                 }
 
                 if ((type_id = record->operands[1]) >= type_count)
                 {
-                    WARN("Invalid contained type id %"PRIu64" for type %zu.\n", type_id, type_index);
+                    WARN("Invalid contained type id %"PRIu64" for type %u.\n", type_id, type_index);
                     return VKD3D_ERROR_INVALID_SHADER;
                 }
                 type->u.array.elem_type = &sm6->types[type_id];
@@ -1384,13 +1384,13 @@ static enum vkd3d_result sm6_parser_type
                 if (!dxil_record_validate_operand_min_count(record, 2, sm6))
                     return VKD3D_ERROR_INVALID_SHADER;
                 if (record->operands[0])
-                    FIXME("Unhandled vararg function type %zu.\n", type_index);
+                    FIXME("Unhandled vararg function type %u.\n", type_index);
 
                 type->class = TYPE_CLASS_FUNCTION;
 
                 if ((type_id = record->operands[1]) >= type_count)
                 {
-                    WARN("Invalid return type id %"PRIu64" for type %zu.\n", type_id, type_index);
+                    WARN("Invalid return type id %"PRIu64" for type %u.\n", type_id, type_index);
                     return VKD3D_ERROR_INVALID_SHADER;
                 }
 
@@ -1408,7 +1408,7 @@ static enum vkd3d_result sm6_parser_type
                 {
                     if ((type_id = record->operands[j + 2]) >= type_count)
                     {
-                        WARN("Invalid parameter type id %"PRIu64" for type %zu.\n", type_id, type_index);
+                        WARN("Invalid parameter type id %"PRIu64" for type %u.\n", type_id, type_index);
                         vkd3d_free(type->u.function);
                         return VKD3D_ERROR_INVALID_SHADER;
                     }
@@ -1442,7 +1442,7 @@ static enum vkd3d_result sm6_parser_type
                     case 64:
                         break;
                     default:
-                        WARN("Invalid integer width %"PRIu64" for type %zu.\n", width, type_index);
+                        WARN("Invalid integer width %"PRIu64" for type %u.\n", width, type_index);
                         return VKD3D_ERROR_INVALID_SHADER;
                 }
                 type->u.width = width;
@@ -1469,7 +1469,7 @@ static enum vkd3d_result sm6_parser_type
 
                 if ((type_id = record->operands[0]) >= type_count)
                 {
-                    WARN("Invalid pointee type id %"PRIu64" for type %zu.\n", type_id, type_index);
+                    WARN("Invalid pointee type id %"PRIu64" for type %u.\n", type_id, type_index);
                     return VKD3D_ERROR_INVALID_SHADER;
                 }
                 type->u.pointer.type = &sm6->types[type_id];
@@ -1482,7 +1482,7 @@ static enum vkd3d_result sm6_parser_type
                     return VKD3D_ERROR_INVALID_SHADER;
                 if (record->code == TYPE_CODE_STRUCT_NAMED && !struct_name)
                 {
-                    WARN("Missing struct name before struct type %zu.\n", type_index);
+                    WARN("Missing struct name before struct type %u.\n", type_index);
                     return VKD3D_ERROR_INVALID_SHADER;
                 }
 
@@ -1504,7 +1504,7 @@ static enum vkd3d_result sm6_parser_type
                 {
                     if ((type_id = record->operands[j + 1]) >= type_count)
                     {
-                        WARN("Invalid contained type id %"PRIu64" for type %zu.\n", type_id, type_index);
+                        WARN("Invalid contained type id %"PRIu64" for type %u.\n", type_id, type_index);
                         vkd3d_free(type->u.struc);
                         return VKD3D_ERROR_INVALID_SHADER;
                     }
@@ -1531,7 +1531,7 @@ static enum vkd3d_result sm6_parser_type
                     return VKD3D_ERROR_OUT_OF_MEMORY;
                 }
                 if (!struct_name[0])
-                    WARN("Struct name is empty for type %zu.\n", type_index);
+                    WARN("Struct name is empty for type %u.\n", type_index);
                 continue;
 
             case TYPE_CODE_VOID:
@@ -1540,7 +1540,7 @@ static enum vkd3d_result sm6_parser_type
                 break;
 
             default:
-                FIXME("Unhandled type %u at index %zu.\n", record->code, type_index);
+                FIXME("Unhandled type %u at index %u.\n", record->code, type_index);
                 return VKD3D_ERROR_INVALID_SHADER;
         }
         ++sm6->type_count;
@@ -1736,7 +1736,7 @@ static const struct sm6_type *sm6_parser
 {
     if (type_id >= sm6->type_count)
     {
-        WARN("Invalid type index %"PRIu64" at %zu.\n", type_id, sm6->value_count);
+        WARN("Invalid type index %"PRIu64" at %u.\n", type_id, sm6->value_count);
         vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_TYPE_ID,
                 "DXIL type id %"PRIu64" is invalid.", type_id);
         return NULL;
@@ -2156,14 +2156,14 @@ static size_t sm6_parser_get_value_index
     /* This may underflow to produce a forward reference, but it must not exceed the final value count. */
     if (i >= sm6->cur_max_value)
     {
-        WARN("Invalid value index %"PRIx64" at %zu.\n", idx, sm6->value_count);
+        WARN("Invalid value index %"PRIx64" at %u.\n", idx, sm6->value_count);
         vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_OPERAND,
                 "Invalid value relative index %u.", (unsigned int)idx);
         return SIZE_MAX;
     }
     if (i == sm6->value_count)
     {
-        WARN("Invalid value self-reference at %zu.\n", sm6->value_count);
+        WARN("Invalid value self-reference at %u.\n", sm6->value_count);
         vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_OPERAND, "Invalid value self-reference.");
         return SIZE_MAX;
     }
@@ -2301,7 +2301,7 @@ static bool sm6_parser_declare_function(
     fn->value_type = VALUE_TYPE_FUNCTION;
     if (!(fn->u.function.name = sm6_parser_get_global_symbol_name(sm6, sm6->value_count)))
     {
-        WARN("Missing symbol name for function %zu.\n", sm6->value_count);
+        WARN("Missing symbol name for function %u.\n", sm6->value_count);
         fn->u.function.name = "";
     }
 
@@ -2498,7 +2498,7 @@ static enum vkd3d_result sm6_parser_cons
 
         if (!type)
         {
-            WARN("Constant record %zu has no type.\n", value_idx);
+            WARN("Constant record %u has no type.\n", value_idx);
             return VKD3D_ERROR_INVALID_SHADER;
         }
 
@@ -2526,7 +2526,7 @@ static enum vkd3d_result sm6_parser_cons
 
                 if (!sm6_type_is_integer(type))
                 {
-                    WARN("Invalid integer of non-integer type %u at constant idx %zu.\n", type->class, value_idx);
+                    WARN("Invalid integer of non-integer type %u at constant idx %u.\n", type->class, value_idx);
                     return VKD3D_ERROR_INVALID_SHADER;
                 }
 
@@ -2544,7 +2544,7 @@ static enum vkd3d_result sm6_parser_cons
 
                 if (!sm6_type_is_floating_point(type))
                 {
-                    WARN("Invalid float of non-fp type %u at constant idx %zu.\n", type->class, value_idx);
+                    WARN("Invalid float of non-fp type %u at constant idx %u.\n", type->class, value_idx);
                     return VKD3D_ERROR_INVALID_SHADER;
                 }
 
@@ -3512,9 +3512,9 @@ static void sm6_parser_emit_call(struct
     operand_count = type->u.function->param_count;
     if (operand_count > ARRAY_SIZE(operands))
     {
-        WARN("Ignoring %zu operands.\n", operand_count - ARRAY_SIZE(operands));
+        WARN("Ignoring %u operands.\n", operand_count - ARRAY_SIZE(operands));
         vkd3d_shader_parser_warning(&sm6->p, VKD3D_SHADER_WARNING_DXIL_IGNORING_OPERANDS,
-                "Ignoring %zu operands for function call.", operand_count - ARRAY_SIZE(operands));
+                "Ignoring %u operands for function call.", operand_count - ARRAY_SIZE(operands));
         operand_count = ARRAY_SIZE(operands);
     }
 
@@ -4177,7 +4177,7 @@ static enum vkd3d_result sm6_parser_func
     if (block->record_count < 2)
     {
         /* It should contain at least a block count and a RET instruction. */
-        WARN("Invalid function block record count %zu.\n", block->record_count);
+        WARN("Invalid function block record count %u.\n", block->record_count);
         return VKD3D_ERROR_INVALID_SHADER;
     }
     if (block->records[0]->code != FUNC_CODE_DECLAREBLOCKS || !block->records[0]->operand_count
@@ -4214,9 +4214,9 @@ static enum vkd3d_result sm6_parser_func
 
         if (!code_block)
         {
-            WARN("Invalid block count %zu.\n", function->block_count);
+            WARN("Invalid block count %u.\n", function->block_count);
             vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_OPERAND,
-                    "Invalid block count %zu.", function->block_count);
+                    "Invalid block count %u.", function->block_count);
             return VKD3D_ERROR_INVALID_SHADER;
         }
 
@@ -5487,9 +5487,9 @@ static enum vkd3d_result sm6_parser_init
     count = byte_code_size / sizeof(*byte_code);
     if (count < 6)
     {
-        WARN("Invalid data size %zu.\n", byte_code_size);
+        WARN("Invalid data size %u.\n", byte_code_size);
         vkd3d_shader_error(message_context, &location, VKD3D_SHADER_ERROR_DXIL_INVALID_SIZE,
-                "DXIL chunk size %zu is smaller than the DXIL header size.", byte_code_size);
+                "DXIL chunk size %u is smaller than the DXIL header size.", byte_code_size);
         return VKD3D_ERROR_INVALID_SHADER;
     }
 
@@ -5500,9 +5500,9 @@ static enum vkd3d_result sm6_parser_init
 
     if (token_count < 6 || count < token_count)
     {
-        WARN("Invalid token count %u (word count %zu).\n", token_count, count);
+        WARN("Invalid token count %u (word count %u).\n", token_count, count);
         vkd3d_shader_error(message_context, &location, VKD3D_SHADER_ERROR_DXIL_INVALID_CHUNK_SIZE,
-                "DXIL chunk token count %#x is invalid (word count %zu).", token_count, count);
+                "DXIL chunk token count %#x is invalid (word count %u).", token_count, count);
         return VKD3D_ERROR_INVALID_SHADER;
     }
 
@@ -5518,18 +5518,18 @@ static enum vkd3d_result sm6_parser_init
     chunk_offset = byte_code[4];
     if (chunk_offset < 16 || chunk_offset >= byte_code_size)
     {
-        WARN("Invalid bitcode chunk offset %#x (data size %zu).\n", chunk_offset, byte_code_size);
+        WARN("Invalid bitcode chunk offset %#x (data size %u).\n", chunk_offset, byte_code_size);
         vkd3d_shader_error(message_context, &location, VKD3D_SHADER_ERROR_DXIL_INVALID_CHUNK_OFFSET,
-                "DXIL bitcode chunk has invalid offset %#x (data size %#zx).", chunk_offset, byte_code_size);
+                "DXIL bitcode chunk has invalid offset %#x (data size %#x).", chunk_offset, byte_code_size);
         return VKD3D_ERROR_INVALID_SHADER;
     }
     chunk_size = byte_code[5];
     if (chunk_size > byte_code_size - chunk_offset)
     {
-        WARN("Invalid bitcode chunk size %#x (data size %zu, chunk offset %#x).\n",
+        WARN("Invalid bitcode chunk size %#x (data size %u, chunk offset %#x).\n",
                 chunk_size, byte_code_size, chunk_offset);
         vkd3d_shader_error(message_context, &location, VKD3D_SHADER_ERROR_DXIL_INVALID_CHUNK_SIZE,
-                "DXIL bitcode chunk has invalid size %#x (data size %#zx, chunk offset %#x).",
+                "DXIL bitcode chunk has invalid size %#x (data size %#x, chunk offset %#x).",
                 chunk_size, byte_code_size, chunk_offset);
         return VKD3D_ERROR_INVALID_SHADER;
     }
@@ -5590,17 +5590,17 @@ static enum vkd3d_result sm6_parser_init
     length = sm6->ptr - sm6->start - block->start;
     if (length != block->length)
     {
-        WARN("Invalid block length %zu; expected %u.\n", length, block->length);
+        WARN("Invalid block length %u; expected %u.\n", length, block->length);
         vkd3d_shader_parser_warning(&sm6->p, VKD3D_SHADER_WARNING_DXIL_INVALID_BLOCK_LENGTH,
-                "Root block ends with length %zu but indicated length is %u.", length, block->length);
+                "Root block ends with length %u but indicated length is %u.", length, block->length);
     }
     if (sm6->ptr != sm6->end)
     {
         size_t expected_length = sm6->end - sm6->start;
         length = sm6->ptr - sm6->start;
-        WARN("Invalid module length %zu; expected %zu.\n", length, expected_length);
+        WARN("Invalid module length %u; expected %u.\n", length, expected_length);
         vkd3d_shader_parser_warning(&sm6->p, VKD3D_SHADER_WARNING_DXIL_INVALID_MODULE_LENGTH,
-                "Module ends with length %zu but indicated length is %zu.", length, expected_length);
+                "Module ends with length %u but indicated length is %u.", length, expected_length);
     }
 
     if ((ret = sm6_parser_type_table_init(sm6)) < 0)
--- a/libs/vkd3d/libs/vkd3d-shader/tpf.c
+++ b/libs/vkd3d/libs/vkd3d-shader/tpf.c
@@ -903,7 +903,7 @@ static void shader_sm4_read_dcl_sampler(
 
     ins->flags = (opcode_token & VKD3D_SM4_SAMPLER_MODE_MASK) >> VKD3D_SM4_SAMPLER_MODE_SHIFT;
     if (ins->flags & ~VKD3D_SM4_SAMPLER_COMPARISON)
-        FIXME("Unhandled sampler mode %#x.\n", ins->flags);
+        FIXME("Unhandled sampler mode %#lx.\n", ins->flags);
     shader_sm4_read_src_param(priv, &tokens, end, VKD3D_DATA_SAMPLER, &ins->declaration.sampler.src);
     shader_sm4_set_descriptor_register_range(priv, &ins->declaration.sampler.src.reg, &ins->declaration.sampler.range);
     shader_sm4_read_register_space(priv, &tokens, end, &ins->declaration.sampler.range.space);
@@ -2256,7 +2256,7 @@ static void shader_sm4_read_instruction_
             } aoffimmi;
 
             if (modifier & ~recognized_bits)
-                FIXME("Unhandled instruction modifier %#x.\n", modifier);
+                FIXME("Unhandled instruction modifier %#lx.\n", modifier);
 
             aoffimmi.u = (modifier & VKD3D_SM4_AOFFIMMI_U_MASK) >> VKD3D_SM4_AOFFIMMI_U_SHIFT;
             aoffimmi.v = (modifier & VKD3D_SM4_AOFFIMMI_V_MASK) >> VKD3D_SM4_AOFFIMMI_V_SHIFT;
@@ -2313,7 +2313,7 @@ static void shader_sm4_read_instruction_
         }
 
         default:
-            FIXME("Unhandled instruction modifier %#x.\n", modifier);
+            FIXME("Unhandled instruction modifier %#lx.\n", modifier);
     }
 }
 
@@ -2353,7 +2353,7 @@ static void shader_sm4_read_instruction(
     }
     if (!len || remaining < len)
     {
-        WARN("Read invalid length %u (remaining %zu).\n", len, remaining);
+        WARN("Read invalid length %u (remaining %u).\n", len, remaining);
         goto fail;
     }
     --len;
