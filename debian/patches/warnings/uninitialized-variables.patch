description: fix uninitialized variable compiler warnings
author: Michael Gilbert <mgilbert@debian.org>

--- a/dlls/comdlg32/filedlg.c
+++ b/dlls/comdlg32/filedlg.c
@@ -238,7 +238,7 @@ static BOOL get_config_key_dword(HKEY hk
 
 static BOOL get_config_key_string(HKEY hkey, const WCHAR *name, WCHAR **value)
 {
-    DWORD type, size;
+    DWORD type, size = 0;
     WCHAR *str;
 
     if (RegQueryValueExW(hkey, name, 0, &type, NULL, &size))
--- a/dlls/d3dx9_36/texture.c
+++ b/dlls/d3dx9_36/texture.c
@@ -1264,7 +1264,7 @@ static inline void fill_texture(const st
 
     for (c = 0; c < 4; c++)
     {
-        float comp_value;
+        float comp_value = 0.f;
         DWORD i, v = 0, mask32 = format->bits[c] == 32 ? ~0U : ((1 << format->bits[c]) - 1);
 
         switch (c)
--- a/dlls/msvcrt/misc.c
+++ b/dlls/msvcrt/misc.c
@@ -269,7 +269,7 @@ static void small_sort(void *base, size_
         int (CDECL *compar)(void *, const void *, const void *), void *context)
 {
     size_t e, i;
-    char *max, *p;
+    char *max, *p = NULL;
 
     for(e=nmemb; e>1; e--) {
         max = base;
--- a/dlls/msxml3/xdr.c
+++ b/dlls/msxml3/xdr.c
@@ -596,6 +596,9 @@ static xmlNodePtr XDR_E_ElementType(xmlN
                         case ORDER_ONE:
                             xsd_child = xmlNewChild(xsd_base, NULL, xs_all, NULL);
                             break;
+                        default:
+                            xsd_child = NULL;
+                            ERR("Unhandled order enum %d\n", (int)order);
                     }
 
                     FOREACH_CHILD(xdr, xdr_child)
--- a/dlls/ole32/datacache.c
+++ b/dlls/ole32/datacache.c
@@ -2516,7 +2516,7 @@ static HRESULT WINAPI DataCache_EnumCach
     DataCacheEntry *cache_entry;
     int i = 0, count = 0;
     STATDATA *data;
-    HRESULT hr;
+    HRESULT hr = E_FAIL;
 
     TRACE( "(%p, %p)\n", This, enum_stat );
 
--- a/dlls/webservices/reader.c
+++ b/dlls/webservices/reader.c
@@ -2043,7 +2043,7 @@ static inline BOOL is_element_type( unsi
 
 static HRESULT read_attributes_bin( struct reader *reader, WS_XML_ELEMENT_NODE *elem )
 {
-    WS_XML_ATTRIBUTE *attr;
+    WS_XML_ATTRIBUTE *attr = NULL;
     unsigned char type;
     HRESULT hr;
 
@@ -6430,7 +6430,7 @@ static HRESULT read_type_struct( struct
                                  WS_HEAP *heap, void *ret, ULONG size, BOOL *found )
 {
     ULONG i, offset;
-    HRESULT hr;
+    HRESULT hr = E_FAIL;
     char *buf;
 
     if (!desc) return E_INVALIDARG;
--- a/dlls/wined3d/utils.c
+++ b/dlls/wined3d/utils.c
@@ -2682,6 +2682,9 @@ static void check_fbo_compat(struct wine
                     case WINED3D_GL_RES_TYPE_COUNT:
                         color = 0;
                         break;
+                    default:
+                        color = 0;
+                        ERR("Unhandled type enum %d\n", (int)type);
                 }
                 checkGLcall("Post-pixelshader blending check");
 
--- a/tools/winedump/msc.c
+++ b/tools/winedump/msc.c
@@ -502,7 +502,7 @@ static void do_field(const unsigned char
     const unsigned char*        ptr = start;
     const char*                 cstr;
     const struct p_string*      pstr;
-    int leaf_len, value;
+    int leaf_len, value = 0;
     struct full_value full_value;
 
     while (ptr < end)
@@ -810,7 +810,7 @@ static void do_field(const unsigned char
 static void codeview_dump_one_type(unsigned curr_type, const union codeview_type* type)
 {
     const union codeview_reftype* reftype = (const union codeview_reftype*)type;
-    int                 i, leaf_len, value;
+    int                 i, leaf_len, value = 0;
     unsigned int        j;
     const char*         str;
 
--- a/tools/winebuild/import.c
+++ b/tools/winebuild/import.c
@@ -165,8 +165,11 @@ static int func_cmp( const void *func1,
 {
     const ORDDEF *odp1 = *(const ORDDEF * const *)func1;
     const ORDDEF *odp2 = *(const ORDDEF * const *)func2;
-    return strcmp( odp1->name ? odp1->name : odp1->export_name,
-                   odp2->name ? odp2->name : odp2->export_name );
+    const char *name1 = odp1->name ? odp1->name : odp1->export_name;
+    const char *name2 = odp2->name ? odp2->name : odp2->export_name;
+    if ( !name1 || !name2 )
+      fatal_error("Unable to compare function names\n");
+    return strcmp( name1, name2 );
 }
 
 /* remove a name from a name table */
--- a/dlls/mciseq/mcimidi.c
+++ b/dlls/mciseq/mcimidi.c
@@ -247,9 +247,9 @@ static DWORD	MIDI_mciReadNextEvent(WINE_
 {
     BYTE	b1, b2 = 0, b3;
     WORD	hw = 0;
-    DWORD	evtPulse;
+    DWORD	evtPulse = 0;
     DWORD	evtLength;
-    DWORD	tmp;
+    DWORD	tmp = 0;
 
     if (mmioSeek(wmm->hFile, mmt->dwIndex, SEEK_SET) != mmt->dwIndex) {
 	WARN("Can't seek at %08lX\n", mmt->dwIndex);
--- a/dlls/msi/automation.c
+++ b/dlls/msi/automation.c
@@ -1821,7 +1821,7 @@ static HRESULT InstallerImpl_SummaryInfo
     UINT ret;
     HRESULT hr;
     MSIHANDLE hsuminfo;
-    IDispatch *dispatch;
+    IDispatch *dispatch = NULL;
     VARIANTARG varg0, varg1;
 
     if (!(wFlags & DISPATCH_PROPERTYGET))
--- a/dlls/mf/session.c
+++ b/dlls/mf/session.c
@@ -501,7 +501,7 @@ static void session_clear_queued_topolog
 static void session_set_topo_status(struct media_session *session, HRESULT status,
         MF_TOPOSTATUS topo_status)
 {
-    IMFMediaEvent *event;
+    IMFMediaEvent *event = NULL;
     PROPVARIANT param;
 
     if (topo_status == MF_TOPOSTATUS_INVALID)
--- a/dlls/d3dx9_36/mesh.c
+++ b/dlls/d3dx9_36/mesh.c
@@ -5553,7 +5553,8 @@ static BOOL attempt_line_merge(struct ou
                                BOOL to_curve,
                                const struct cos_table *table)
 {
-    D3DXVECTOR2 curdir, lastdir;
+    D3DXVECTOR2 curdir = {0.0f, 0.0f};
+    D3DXVECTOR2 lastdir = {0.0f, 0.0f};
     struct point2d *prevpt, *pt;
     BOOL ret = FALSE;
 
--- a/dlls/win32u/region.c
+++ b/dlls/win32u/region.c
@@ -405,6 +405,7 @@ static BOOL init_region( WINEREGION *pRe
 {
     n = max( n, RGN_DEFAULT_RECTS );
 
+    pReg->rects = NULL;
     if (n > RGN_DEFAULT_RECTS)
     {
         if (n > INT_MAX / sizeof(RECT)) return FALSE;
--- a/dlls/win32u/dc.c
+++ b/dlls/win32u/dc.c
@@ -974,6 +974,7 @@ BOOL WINAPI NtGdiGetAndSetDCDword( HDC h
 
     default:
         WARN( "unknown method %u\n", method );
+        prev = 0;
         ret = FALSE;
         break;
     }
--- a/dlls/iphlpapi/iphlpapi_main.c
+++ b/dlls/iphlpapi/iphlpapi_main.c
@@ -994,7 +994,9 @@ static DWORD gateway_and_prefix_addresse
     struct nsi_ipv6_forward_key *key6;
     IP_ADAPTER_GATEWAY_ADDRESS *gw, **gw_next;
     IP_ADAPTER_PREFIX *prefix, **prefix_next;
-    DWORD err, count, i, prefix_len, key_size = (family == AF_INET) ? sizeof(*key4) : sizeof(*key6);
+    DWORD err, count, i;
+    DWORD prefix_len = 0;
+    DWORD key_size = (family == AF_INET) ? sizeof(*key4) : sizeof(*key6);
     DWORD sockaddr_size = (family == AF_INET) ? sizeof(SOCKADDR_IN) : sizeof(SOCKADDR_IN6);
     SOCKADDR_INET sockaddr;
     NET_LUID *luid;
@@ -1088,6 +1090,11 @@ static DWORD gateway_and_prefix_addresse
                         err = ERROR_NOT_ENOUGH_MEMORY;
                         goto err;
                     }
+                    if (prefix_len == 0)
+                    {
+                        err = ERROR_INVALID_DATA;
+                        goto err;
+                    }
                     prefix->Length = sizeof(*prefix);
                     prefix->Address.lpSockaddr = (SOCKADDR *)(prefix + 1);
                     prefix->Address.iSockaddrLength = sockaddr_size;
--- a/include/winsock2.h
+++ b/include/winsock2.h
@@ -605,9 +605,17 @@ typedef struct WS(timeval)
 #  define FD_SETSIZE    64
 # endif
 
+# define FD_ZERO(set) { \
+    unsigned int __i; \
+    (((fd_set*)(set))->fd_count=0); \
+    for (__i = 0; __i < FD_SETSIZE; __i++) \
+    { \
+        (((fd_set*)(set))->fd_array[__i] = SOCKET_ERROR); \
+    } \
+}
+
 # define FD_CLR(fd, set)      __WS_FD_CLR((fd), (set), fd_set)
 # define FD_SET(fd, set)      __WS_FD_SET((fd), (set), fd_set)
-# define FD_ZERO(set)         (((fd_set*)(set))->fd_count=0)
 # define FD_ISSET(fd, set)    __WSAFDIsSet((SOCKET)(fd), (fd_set*)(set))
 
 #else
--- a/dlls/ntdll/unix/env.c
+++ b/dlls/ntdll/unix/env.c
@@ -1904,7 +1904,8 @@ static RTL_USER_PROCESS_PARAMETERS *buil
     static const WCHAR valueW[] = {'1',0};
     static const WCHAR pathW[] = {'P','A','T','H'};
     RTL_USER_PROCESS_PARAMETERS *params = NULL;
-    SIZE_T size, env_pos, env_size;
+    SIZE_T env_pos = 0;
+    SIZE_T size, env_size;
     WCHAR *dst, *image, *cmdline, *path, *bootstrap;
     WCHAR *env = get_initial_environment( &env_pos, &env_size );
     WCHAR *curdir = get_initial_directory();
--- a/dlls/winex11.drv/window.c
+++ b/dlls/winex11.drv/window.c
@@ -2364,11 +2364,14 @@ void X11DRV_GetDC( HDC hdc, HWND hwnd, H
     }
     else
     {
+        Drawable top_window = X11DRV_get_whole_window( top );
+        escape.drawable = top_window;
+
         /* find the first ancestor that has a drawable */
         for (parent = hwnd; parent && parent != top; parent = NtUserGetAncestor( parent, GA_PARENT ))
             if ((escape.drawable = X11DRV_get_whole_window( parent ))) break;
 
-        if (escape.drawable)
+        if (escape.drawable != top_window)
         {
             POINT pt = { 0, 0 };
             NtUserMapWindowPoints( 0, parent, &pt, 1 );
@@ -2376,7 +2379,6 @@ void X11DRV_GetDC( HDC hdc, HWND hwnd, H
             OffsetRect( &escape.dc_rect, pt.x, pt.y );
             if (flags & DCX_CLIPCHILDREN) escape.mode = ClipByChildren;
         }
-        else escape.drawable = X11DRV_get_whole_window( top );
     }
 
     NtGdiExtEscape( hdc, NULL, 0, X11DRV_ESCAPE, sizeof(escape), (LPSTR)&escape, 0, NULL );
--- a/dlls/user.exe16/message.c
+++ b/dlls/user.exe16/message.c
@@ -403,7 +403,7 @@ static EDITWORDBREAKPROC16 get_word_brea
 
 static inline void *get_buffer( void *static_buffer, size_t size, size_t need )
 {
-    if (size >= need) return static_buffer;
+    if (size >= need) return NULL;
     return HeapAlloc( GetProcessHeap(), 0, need );
 }
 
@@ -1457,6 +1457,11 @@ LRESULT WINPROC_CallProc32ATo16( winproc
         {
             RECT *r32 = (RECT *)lParam;
             RECT16 rect;
+            rect.left = 0;
+            rect.top = 0;
+            rect.right = 0;
+            rect.bottom = 0;
+
             lParam = MapLS( &rect );
             ret = callback( HWND_16(hwnd),
                             (msg == LB_GETITEMRECT) ? LB_GETITEMRECT16 : CB_GETDROPPEDCONTROLRECT16,
--- a/dlls/kernelbase/loader.c
+++ b/dlls/kernelbase/loader.c
@@ -326,7 +326,7 @@ done:
  */
 HMODULE WINAPI DECLSPEC_HOTPATCH GetModuleHandleA( LPCSTR module )
 {
-    HMODULE ret;
+    HMODULE ret = NULL;
 
     GetModuleHandleExA( GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT, module, &ret );
     return ret;
@@ -338,7 +338,7 @@ HMODULE WINAPI DECLSPEC_HOTPATCH GetModu
  */
 HMODULE WINAPI DECLSPEC_HOTPATCH GetModuleHandleW( LPCWSTR module )
 {
-    HMODULE ret;
+    HMODULE ret = NULL;
 
     GetModuleHandleExW( GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT, module, &ret );
     return ret;
--- a/dlls/user32/winproc.c
+++ b/dlls/user32/winproc.c
@@ -1195,6 +1195,7 @@ BOOL WINAPI User32CallWindowProc( struct
         else
         {
             size = sizeof(stack_buffer);
+            for (ULONG i = 0; i < size; ++i) stack_buffer[i] = '\0';
             buffer = stack_buffer;
         }
         if (!unpack_message( params->hwnd, params->msg, &params->wparam,
