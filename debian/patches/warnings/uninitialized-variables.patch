description: fix uninitialized variable compiler warnings
author: Michael Gilbert <mgilbert@debian.org>

--- a/dlls/comdlg32/filedlg.c
+++ b/dlls/comdlg32/filedlg.c
@@ -238,7 +238,7 @@ static BOOL get_config_key_dword(HKEY hk
 
 static BOOL get_config_key_string(HKEY hkey, const WCHAR *name, WCHAR **value)
 {
-    DWORD type, size;
+    DWORD type, size = 0;
     WCHAR *str;
 
     if (RegQueryValueExW(hkey, name, 0, &type, NULL, &size))
--- a/dlls/d3dx9_36/texture.c
+++ b/dlls/d3dx9_36/texture.c
@@ -1269,7 +1269,7 @@ static inline void fill_texture(const st
 
     for (c = 0; c < 4; c++)
     {
-        float comp_value;
+        float comp_value = 0.f;
         DWORD i, v = 0, mask32 = format->bits[c] == 32 ? ~0U : ((1 << format->bits[c]) - 1);
 
         switch (c)
--- a/dlls/ntdll/locale.c
+++ b/dlls/ntdll/locale.c
@@ -1387,7 +1387,7 @@ NTSTATUS WINAPI RtlIdnToUnicode( DWORD f
     int i, buflen, start, end, out_label, out = 0;
     NTSTATUS status;
     UINT buffer[64];
-    WCHAR ch;
+    WCHAR ch = '\0';
 
     if (!src || srclen < -1) return STATUS_INVALID_PARAMETER;
     if (srclen == -1) srclen = wcslen( src ) + 1;
--- a/dlls/msvcrt/misc.c
+++ b/dlls/msvcrt/misc.c
@@ -269,7 +269,7 @@ static void small_sort(void *base, size_
         int (CDECL *compar)(void *, const void *, const void *), void *context)
 {
     size_t e, i;
-    char *max, *p;
+    char *max, *p = NULL;
 
     for(e=nmemb; e>1; e--) {
         max = base;
--- a/dlls/msxml3/xdr.c
+++ b/dlls/msxml3/xdr.c
@@ -596,6 +596,9 @@ static xmlNodePtr XDR_E_ElementType(xmlN
                         case ORDER_ONE:
                             xsd_child = xmlNewChild(xsd_base, NULL, xs_all, NULL);
                             break;
+                        default:
+                            xsd_child = NULL;
+                            ERR("Unhandled order enum %d\n", (int)order);
                     }
 
                     FOREACH_CHILD(xdr, xdr_child)
--- a/dlls/ole32/datacache.c
+++ b/dlls/ole32/datacache.c
@@ -2516,7 +2516,7 @@ static HRESULT WINAPI DataCache_EnumCach
     DataCacheEntry *cache_entry;
     int i = 0, count = 0;
     STATDATA *data;
-    HRESULT hr;
+    HRESULT hr = E_FAIL;
 
     TRACE( "(%p, %p)\n", This, enum_stat );
 
--- a/dlls/webservices/reader.c
+++ b/dlls/webservices/reader.c
@@ -2043,7 +2043,7 @@ static inline BOOL is_element_type( unsi
 
 static HRESULT read_attributes_bin( struct reader *reader, WS_XML_ELEMENT_NODE *elem )
 {
-    WS_XML_ATTRIBUTE *attr;
+    WS_XML_ATTRIBUTE *attr = NULL;
     unsigned char type;
     HRESULT hr;
 
@@ -6430,7 +6430,7 @@ static HRESULT read_type_struct( struct
                                  WS_HEAP *heap, void *ret, ULONG size, BOOL *found )
 {
     ULONG i, offset;
-    HRESULT hr;
+    HRESULT hr = E_FAIL;
     char *buf;
 
     if (!desc) return E_INVALIDARG;
--- a/dlls/wined3d/utils.c
+++ b/dlls/wined3d/utils.c
@@ -2673,6 +2673,9 @@ static void check_fbo_compat(struct wine
                     case WINED3D_GL_RES_TYPE_COUNT:
                         color = 0;
                         break;
+                    default:
+                        color = 0;
+                        ERR("Unhandled type enum %d\n", (int)type);
                 }
                 checkGLcall("Post-pixelshader blending check");
 
--- a/tools/winedump/msc.c
+++ b/tools/winedump/msc.c
@@ -503,7 +503,7 @@ static void do_field(const unsigned char
     const unsigned char*        ptr = start;
     const char*                 cstr;
     const struct p_string*      pstr;
-    int leaf_len, value;
+    int leaf_len, value = 0;
     struct full_value full_value;
 
     while (ptr < end)
@@ -811,7 +811,7 @@ static void do_field(const unsigned char
 static void codeview_dump_one_type(unsigned curr_type, const union codeview_type* type)
 {
     const union codeview_reftype* reftype = (const union codeview_reftype*)type;
-    int                 i, leaf_len, value;
+    int                 i, leaf_len, value = 0;
     unsigned int        j;
     const char*         str;
 
--- a/tools/winebuild/import.c
+++ b/tools/winebuild/import.c
@@ -165,8 +165,11 @@ static int func_cmp( const void *func1,
 {
     const ORDDEF *odp1 = *(const ORDDEF * const *)func1;
     const ORDDEF *odp2 = *(const ORDDEF * const *)func2;
-    return strcmp( odp1->name ? odp1->name : odp1->export_name,
-                   odp2->name ? odp2->name : odp2->export_name );
+    const char *name1 = odp1->name ? odp1->name : odp1->export_name;
+    const char *name2 = odp2->name ? odp2->name : odp2->export_name;
+    if ( !name1 || !name2 )
+      fatal_error("Unable to compare function names\n");
+    return strcmp( name1, name2 );
 }
 
 /* remove a name from a name table */
--- a/dlls/mciseq/mcimidi.c
+++ b/dlls/mciseq/mcimidi.c
@@ -247,9 +247,9 @@ static DWORD	MIDI_mciReadNextEvent(WINE_
 {
     BYTE	b1, b2 = 0, b3;
     WORD	hw = 0;
-    DWORD	evtPulse;
+    DWORD	evtPulse = 0;
     DWORD	evtLength;
-    DWORD	tmp;
+    DWORD	tmp = 0;
 
     if (mmioSeek(wmm->hFile, mmt->dwIndex, SEEK_SET) != mmt->dwIndex) {
 	WARN("Can't seek at %08lX\n", mmt->dwIndex);
--- a/dlls/msi/automation.c
+++ b/dlls/msi/automation.c
@@ -1819,7 +1819,7 @@ static HRESULT InstallerImpl_SummaryInfo
     UINT ret;
     HRESULT hr;
     MSIHANDLE hsuminfo;
-    IDispatch *dispatch;
+    IDispatch *dispatch = NULL;
     VARIANTARG varg0, varg1;
 
     if (!(wFlags & DISPATCH_PROPERTYGET))
--- a/dlls/mf/session.c
+++ b/dlls/mf/session.c
@@ -507,7 +507,7 @@ static void session_clear_queued_topolog
 static void session_set_topo_status(struct media_session *session, HRESULT status,
         MF_TOPOSTATUS topo_status)
 {
-    IMFMediaEvent *event;
+    IMFMediaEvent *event = NULL;
     PROPVARIANT param;
 
     if (topo_status == MF_TOPOSTATUS_INVALID)
--- a/dlls/d3dx9_36/mesh.c
+++ b/dlls/d3dx9_36/mesh.c
@@ -5524,7 +5524,8 @@ static BOOL attempt_line_merge(struct ou
                                BOOL to_curve,
                                const struct cos_table *table)
 {
-    D3DXVECTOR2 curdir, lastdir;
+    D3DXVECTOR2 curdir = {0.0f, 0.0f};
+    D3DXVECTOR2 lastdir = {0.0f, 0.0f};
     struct point2d *prevpt, *pt;
     BOOL ret = FALSE;
 
--- a/dlls/win32u/region.c
+++ b/dlls/win32u/region.c
@@ -405,6 +405,7 @@ static BOOL init_region( WINEREGION *pRe
 {
     n = max( n, RGN_DEFAULT_RECTS );
 
+    pReg->rects = NULL;
     if (n > RGN_DEFAULT_RECTS)
     {
         if (n > INT_MAX / sizeof(RECT)) return FALSE;
--- a/dlls/win32u/dc.c
+++ b/dlls/win32u/dc.c
@@ -949,6 +949,7 @@ BOOL WINAPI NtGdiGetAndSetDCDword( HDC h
 
     default:
         WARN( "unknown method %u\n", method );
+        prev = 0;
         ret = FALSE;
         break;
     }
--- a/dlls/iphlpapi/iphlpapi_main.c
+++ b/dlls/iphlpapi/iphlpapi_main.c
@@ -992,7 +992,9 @@ static DWORD gateway_and_prefix_addresse
     struct nsi_ipv6_forward_key *key6;
     IP_ADAPTER_GATEWAY_ADDRESS *gw, **gw_next;
     IP_ADAPTER_PREFIX *prefix, **prefix_next;
-    DWORD err, count, i, prefix_len, key_size = (family == AF_INET) ? sizeof(*key4) : sizeof(*key6);
+    DWORD err, count, i;
+    DWORD prefix_len = 0;
+    DWORD key_size = (family == AF_INET) ? sizeof(*key4) : sizeof(*key6);
     DWORD sockaddr_size = (family == AF_INET) ? sizeof(SOCKADDR_IN) : sizeof(SOCKADDR_IN6);
     SOCKADDR_INET sockaddr;
     NET_LUID *luid;
@@ -1086,6 +1088,11 @@ static DWORD gateway_and_prefix_addresse
                         err = ERROR_NOT_ENOUGH_MEMORY;
                         goto err;
                     }
+                    if (prefix_len == 0)
+                    {
+                        err = ERROR_INVALID_DATA;
+                        goto err;
+                    }
                     prefix->Length = sizeof(*prefix);
                     prefix->Address.lpSockaddr = (SOCKADDR *)(prefix + 1);
                     prefix->Address.iSockaddrLength = sockaddr_size;
--- a/include/winsock2.h
+++ b/include/winsock2.h
@@ -597,9 +597,17 @@ typedef struct WS(timeval)
 #  define FD_SETSIZE    64
 # endif
 
+# define FD_ZERO(set) { \
+    unsigned int __i; \
+    (((fd_set*)(set))->fd_count=0); \
+    for (__i = 0; __i < FD_SETSIZE; __i++) \
+    { \
+        (((fd_set*)(set))->fd_array[__i] = SOCKET_ERROR); \
+    } \
+}
+
 # define FD_CLR(fd, set)      __WS_FD_CLR((fd), (set), fd_set)
 # define FD_SET(fd, set)      __WS_FD_SET((fd), (set), fd_set)
-# define FD_ZERO(set)         (((fd_set*)(set))->fd_count=0)
 # define FD_ISSET(fd, set)    __WSAFDIsSet((SOCKET)(fd), (fd_set*)(set))
 
 #else
--- a/dlls/ntdll/unix/env.c
+++ b/dlls/ntdll/unix/env.c
@@ -1890,7 +1890,8 @@ static RTL_USER_PROCESS_PARAMETERS *buil
     static const WCHAR valueW[] = {'1',0};
     static const WCHAR pathW[] = {'P','A','T','H'};
     RTL_USER_PROCESS_PARAMETERS *params = NULL;
-    SIZE_T size, env_pos, env_size;
+    SIZE_T env_pos = 0;
+    SIZE_T size, env_size;
     WCHAR *dst, *image, *cmdline, *path, *bootstrap;
     WCHAR *env = get_initial_environment( &env_pos, &env_size );
     WCHAR *curdir = get_initial_directory();
--- a/dlls/winex11.drv/window.c
+++ b/dlls/winex11.drv/window.c
@@ -2315,11 +2315,14 @@ void X11DRV_GetDC( HDC hdc, HWND hwnd, H
     }
     else
     {
+        Drawable top_window = X11DRV_get_whole_window( top );
+        escape.drawable = top_window;
+
         /* find the first ancestor that has a drawable */
         for (parent = hwnd; parent && parent != top; parent = NtUserGetAncestor( parent, GA_PARENT ))
             if ((escape.drawable = X11DRV_get_whole_window( parent ))) break;
 
-        if (escape.drawable)
+        if (escape.drawable != top_window)
         {
             POINT pt = { 0, 0 };
             NtUserMapWindowPoints( 0, parent, &pt, 1 );
@@ -2327,7 +2330,6 @@ void X11DRV_GetDC( HDC hdc, HWND hwnd, H
             OffsetRect( &escape.dc_rect, pt.x, pt.y );
             if (flags & DCX_CLIPCHILDREN) escape.mode = ClipByChildren;
         }
-        else escape.drawable = X11DRV_get_whole_window( top );
     }
 
     NtGdiExtEscape( hdc, NULL, 0, X11DRV_ESCAPE, sizeof(escape), (LPSTR)&escape, 0, NULL );
--- a/dlls/comctl32/button.c
+++ b/dlls/comctl32/button.c
@@ -1833,7 +1833,8 @@ static void BUTTON_DrawThemedLabel(const
 static void PB_Paint( const BUTTON_INFO *infoPtr, HDC hDC, UINT action )
 {
     RECT     rc, labelRect, imageRect, textRect;
-    UINT     dtFlags, uState;
+    UINT     uState;
+    UINT     dtFlags = (UINT)-1L;
     HPEN     hOldPen, hpen;
     HBRUSH   hOldBrush;
     INT      oldBkMode;
--- a/dlls/gdiplus/font.c
+++ b/dlls/gdiplus/font.c
@@ -1396,7 +1396,8 @@ static WCHAR *load_ttf_name_id( const BY
     const tt_header *header;
     const tt_name_table *name_table;
     const tt_name_record *name_record;
-    DWORD pos, ofs, count;
+    DWORD pos, count;
+    DWORD ofs = 0;
     int i, res, best_lang = 0, best_index = -1;
 
     if (sizeof(tt_header) > size)
--- a/dlls/scrobj/scrobj.c
+++ b/dlls/scrobj/scrobj.c
@@ -1188,7 +1188,7 @@ static HRESULT create_scriptlet_instance
     struct script_host *factory_host, *host;
     struct scriptlet_instance *obj;
     IDispatch *script_dispatch;
-    HRESULT hres;
+    HRESULT hres = E_FAIL;
 
     if (!(obj = calloc(1, sizeof(*obj))))
         return E_OUTOFMEMORY;
--- a/dlls/ntdll/unix/socket.c
+++ b/dlls/ntdll/unix/socket.c
@@ -680,7 +680,7 @@ static NTSTATUS sock_recv( HANDLE handle
                            struct WS_sockaddr *addr, int *addr_len, DWORD *ret_flags, int unix_flags, int force_async )
 {
     struct async_recv_ioctl *async;
-    ULONG_PTR information;
+    ULONG_PTR information = 0;
     HANDLE wait_handle;
     DWORD async_size;
     NTSTATUS status;
